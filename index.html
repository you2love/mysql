<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MySQL 学习教程 - 从入门到精通</title>
    <link rel="icon" href="favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="styles.css">
    <script src="mermaid.min.js"></script>
    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default',
            flowchart: {
                useMaxWidth: true,
                htmlLabels: true,
                curve: 'basis'
            },
            sequence: {
                useMaxWidth: true,
                diagramMarginX: 50,
                actorMargin: 50
            }
        });
    </script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.code-block').forEach(function(block) {
                var pre = block.querySelector('pre');
                if (!pre) return;
                
                var code = document.createElement('div');
                code.className = 'code-actions';
                
                var copyBtn = document.createElement('button');
                copyBtn.className = 'copy-btn';
                copyBtn.innerHTML = '📋 复制';
                copyBtn.onclick = function(e) {
                    e.stopPropagation();
                    var text = pre.textContent;
                    navigator.clipboard.writeText(text).then(function() {
                        copyBtn.innerHTML = '✓ 已复制';
                        setTimeout(function() {
                            copyBtn.innerHTML = '📋 复制';
                        }, 2000);
                    });
                };
                
                code.appendChild(copyBtn);
                block.insertBefore(code, pre);
            });

            function wrapLongContent(container) {
                var children = Array.from(container.querySelectorAll(':scope > h3, :scope > h4'));
                
                children.forEach(function(heading) {
                    var contentElements = [];
                    var totalLines = 0;
                    var sibling = heading.nextElementSibling;
                    
                    while (sibling && sibling.tagName !== 'H3' && sibling.tagName !== 'H4') {
                        contentElements.push(sibling);
                        if (sibling.classList && sibling.classList.contains('code-block')) {
                            totalLines += (sibling.textContent || '').split('\n').length;
                        }
                        sibling = sibling.nextElementSibling;
                    }
                    
                    if (totalLines > 15) {
                        var wrapper = document.createElement('div');
                        wrapper.className = 'collapsible-content';
                        contentElements.forEach(function(el) {
                            wrapper.appendChild(el);
                        });
                        
                        var details = document.createElement('details');
                        details.className = 'long-content';
                        var title = heading.textContent;
                        details.innerHTML = '<summary>📖 ' + title + '</summary>';
                        details.appendChild(wrapper);
                        
                        heading.parentNode.replaceChild(details, heading);
                    }
                });
            }

            document.querySelectorAll('.content').forEach(wrapLongContent);
        });
    </script>
</head>
<body>
    <div class="layout">
        <aside class="sidebar">
            <div class="sidebar-header">
                <h1>MySQL 教程</h1>
            </div>
            <nav class="tree-nav">
                <ul class="tree">
                    <li>
                        <a href="#introduction">简介</a>
                    </li>
                    <li>
                        <a href="#alternatives">替代品</a>
                    </li>
                    <li>
                        <a href="#history">发展历程</a>
                    </li>
                    <li>
                        <a href="#installation">安装</a>
                    </li>
                    <li>
                        <a href="#basics">基础操作</a>
                    </li>
                    <li>
                        <a href="#datatypes">数据类型</a>
                    </li>
                    <li>
                        <a href="#advanced">高级特性</a>
                    </li>
                    <li>
                        <a href="#index-theory">索引原理</a>
                    </li>
                    <li>
                        <a href="#performance">性能优化</a>
                    </li>
                    <li>
                        <a href="#security">安全特性</a>
                    </li>
                    <li>
                        <a href="#ai">AI 增强</a>
                    </li>
                    <li>
                        <a href="#practice">实战练习</a>
                    </li>
                </ul>
            </nav>
        </aside>
        <main class="main-content">
            <section id="introduction" class="section">
            <h2>什么是 MySQL？</h2>
            <div class="content">
                <p>MySQL 是世界上最流行的开源关系型数据库管理系统。它支持 AI 驱动的查询优化、机器学习集成、云原生架构等前沿技术。</p>

                <div class="feature-grid">
                    <div class="feature-card">
                        <h3>🎯 开源免费</h3>
                        <p>完全开源，社区活跃，支持 PostgreSQL 协议兼容</p>
                    </div>
                    <div class="feature-card">
                        <h3>⚡ 高性能</h3>
                        <p>AI 驱动的查询优化器，性能提升 40%，支持实时分析</p>
                    </div>
                    <div class="feature-card">
                        <h3>🔒 安全可靠</h3>
                        <p>零信任架构，量子密钥分发支持，端到端加密</p>
                    </div>
                    <div class="feature-card">
                        <h3>🌐 云原生</h3>
                        <p>原生支持 Kubernetes、Serverless 架构，自动扩缩容</p>
                    </div>
                    <div class="feature-card">
                        <h3>🤖 AI 集成</h3>
                        <p>内置机器学习引擎，自动推荐索引、优化查询</p>
                    </div>
                    <div class="feature-card">
                        <h3>📊 实时分析</h3>
                        <p>HTAP 混合事务分析，实时 BI 和 OLAP 能力</p>
                    </div>
                </div>
            </div>
        </section>

        <section id="alternatives" class="section">
            <h2>MySQL 替代品</h2>
            <div class="content">
                <p>在选择数据库时，需要根据业务需求、技术栈和团队技能来权衡。MySQL 是最流行的关系型数据库之一，但市场上还有许多优秀的替代方案。以下是主流数据库的对比分析：</p>
                
                <h3>主流关系型数据库对比</h3>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>数据库</th>
                                <th>类型</th>
                                <th>开源</th>
                                <th>许可证</th>
                                <th>最擅长</th>
                                <th>不适合</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>MySQL</strong></td>
                                <td>关系型</td>
                                <td>✅</td>
                                <td>GPL v2</td>
                                <td>Web应用、电商、内容管理</td>
                                <td>复杂分析、GIS</td>
                            </tr>
                            <tr>
                                <td><strong>PostgreSQL</strong></td>
                                <td>关系型</td>
                                <td>✅</td>
                                <td>PostgreSQL License</td>
                                <td>企业级应用、数据分析、GIS</td>
                                <td>超高性能场景</td>
                            </tr>
                            <tr>
                                <td><strong>MongoDB</strong></td>
                                <td>文档型</td>
                                <td>✅</td>
                                <td>SSPL</td>
                                <td>灵活Schema、日志、内容管理</td>
                                <td>强事务需求</td>
                            </tr>
                            <tr>
                                <td><strong>Redis</strong></td>
                                <td>键值型</td>
                                <td>✅</td>
                                <td>BSD</td>
                                <td>缓存、会话、实时分析</td>
                                <td>主数据存储</td>
                            </tr>
                            <tr>
                                <td><strong>SQL Server</strong></td>
                                <td>关系型</td>
                                <td>❌</td>
                                <td>商业</td>
                                <td>企业应用、BI、Windows生态</td>
                                <td>开源项目、跨平台</td>
                            </tr>
                            <tr>
                                <td><strong>Oracle</strong></td>
                                <td>关系型</td>
                                <td>❌</td>
                                <td>商业</td>
                                <td>大型企业、金融、电信</td>
                                <td>中小型项目</td>
                            </tr>
                            <tr>
                                <td><strong>MariaDB</strong></td>
                                <td>关系型</td>
                                <td>✅</td>
                                <td>GPL v2</td>
                                <td>MySQL兼容、高性能</td>
                                <td>特定企业功能</td>
                            </tr>
                            <tr>
                                <td><strong>TiDB</strong></td>
                                <td>NewSQL</td>
                                <td>✅</td>
                                <td>Apache 2.0</td>
                                <td>分布式、强一致、弹性扩展</td>
                                <td>简单小应用</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>1. PostgreSQL - 最强大的开源数据库</h3>
                <p>PostgreSQL 是功能最强大的开源关系型数据库，以其 extensibility 和标准兼容性著称。</p>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>优点</th>
                                <th>缺点</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>✅ 支持复杂的SQL特性（CTE、窗口函数、物化视图）</td>
                                <td>❌ 写入性能略低于MySQL</td>
                            </tr>
                            <tr>
                                <td>✅ 丰富的索引类型（GIN、GiST、BRIN、表达式索引）</td>
                                <td>❌ 社区相对较小</td>
                            </tr>
                            <tr>
                                <td>✅ 强大的GIS支持（PostGIS）</td>
                                <td>❌ 文档相对分散</td>
                            </tr>
                            <tr>
                                <td>✅ 完整的ACID支持</td>
                                <td>❌ 配置复杂度较高</td>
                            </tr>
                            <tr>
                                <td>✅ 支持JSON/JSONB、数组、全文搜索</td>
                                <td>❌ 不支持多源复制</td>
                            </tr>
                            <tr>
                                <td>✅ 活跃的社区和丰富的插件生态</td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- PostgreSQL 特色功能示例</span>

<span class="com">-- 1. 递归CTE（查询组织架构）</span>
<span class="kwd">WITH</span> <span class="kwd">RECURSIVE</span> org_tree <span class="kwd">AS</span> (
    <span class="kwd">SELECT</span> id, name, manager_id, <span class="num">1</span> <span class="kwd">as</span> <span class="kwd">level</span>
    <span class="kwd">FROM</span> employees <span class="kwd">WHERE</span> manager_id <span class="kwd">IS</span> NULL
    <span class="kwd">UNION ALL</span>
    <span class="kwd">SELECT</span> e.id, e.name, e.manager_id, ot.<span class="kwd">level</span> + <span class="num">1</span>
    <span class="kwd">FROM</span> employees e
    <span class="kwd">JOIN</span> org_tree ot <span class="kwd">ON</span> e.manager_id = ot.id
)
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> org_tree;

<span class="com">-- 2. 窗口函数（排名统计）</span>
<span class="kwd">SELECT</span> 
    name,
    department,
    salary,
    <span class="func">RANK</span>() OVER (<span class="kwd">PARTITION BY</span> department <span class="kwd">ORDER BY</span> salary DESC) <span class="kwd">as</span> dept_rank,
    <span class="func">SUM</span>(salary) OVER (<span class="kwd">PARTITION BY</span> department) <span class="kwd">as</span> dept_total
<span class="kwd">FROM</span> employees;

<span class="com">-- 3. JSONB 操作</span>
<span class="kwd">SELECT</span> data->><span class="str">'name'</span> <span class="kwd">FROM</span> orders
<span class="kwd">WHERE</span> data @> <span class="str">'{"status": "completed"}'</span>;

<span class="com">-- 4. 数组类型</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> tags (
    id <span class="kwd">INT</span>,
    name <span class="type">VARCHAR</span>(<span class="num">50</span>),
    tags <span class="type">TEXT</span>[]
);
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> tags <span class="kwd">VALUES</span>(<span class="num">1</span>, <span class="str">'PostgreSQL'</span>, ARRAY[<span class="str">'database'</span>, <span class="str">'open source'</span>, <span class="str">'relational'</span>]);

<span class="com">-- 5. PostGIS 空间查询</span>
<span class="kwd">SELECT</span> name <span class="kwd">FROM</span> locations
<span class="kwd">WHERE</span> ST_DWithin(location, ST_MakePoint(<span class="num">116.4</span>, <span class="num">39.9</span>)::geography, <span class="num">5000</span>);</code></pre>
                </div>
                
                <h4>适用场景：</h4>
                <ul>
                    <li>需要复杂分析查询的企业应用</li>
                    <li>GIS地理信息系统开发</li>
                    <li>需要JSON和结构化数据混合存储</li>
                    <li>数据仓库和BI分析</li>
                    <li>需要全文搜索功能</li>
                </ul>

                <h3>2. MongoDB - 文档数据库首选</h3>
                <p>MongoDB是最流行的文档型数据库，采用灵活的JSON风格文档模型。</p>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>优点</th>
                                <th>缺点</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>✅ 灵活的Schema，无需预定义表结构</td>
                                <td>❌ 事务支持有限（4.0+有所改善）</td>
                            </tr>
                            <tr>
                                <td>✅ 强大的查询语言和聚合框架</td>
                                <td>❌ 不适合强一致性要求场景</td>
                            </tr>
                            <tr>
                                <td>✅ 高性能，高并发写入</td>
                                <td>❌ 内存占用较高</td>
                            </tr>
                            <tr>
                                <td>✅ 易于水平扩展（分片）</td>
                                <td>❌ 磁盘空间消耗较大</td>
                            </tr>
                            <tr>
                                <td>✅ 丰富的索引支持</td>
                                <td>❌ 学习曲线较陡</td>
                            </tr>
                            <tr>
                                <td>✅ 完善的生态系统</td>
                                <td>❌ 社区版功能受限</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">// MongoDB 特色操作示例

<span class="com">// 1. 插入文档（无需预定义结构）</span>
db.users.insertOne({
    username: <span class="str">"john"</span>,
    email: <span class="str">"john@example.com"</span>,
    profile: {
        age: <span class="num">30</span>,
        city: <span class="str">"Beijing"</span>,
        interests: [<span class="str">"coding"</span>, <span class="str">"music"</span>]
    },
    createdAt: <span class="kwd">new</span> Date()
});

<span class="com">// 2. 灵活查询</span>
db.users.find({
    <span class="str">"profile.age"</span>: { $gt: <span class="num">25</span> },
    <span class="str">"profile.city"</span>: <span class="str">"Beijing"</span>
});

<span class="com">// 3. 聚合管道</span>
db.orders.aggregate([
    { $match: { status: <span class="str">"completed"</span> } },
    { $group: {
        _id: <span class="str">"$customer_id"</span>,
        totalAmount: { $sum: <span class="str">"$amount"</span> },
        orderCount: { $sum: <span class="num">1</span> }
    }},
    { $sort: { totalAmount: -<span class="num">1</span> } },
    { $limit: <span class="num">10</span> }
]);

<span class="com">// 4. 更新数组元素</span>
db.users.updateOne(
    { username: <span class="str">"john"</span> },
    { $push: { <span class="str">"profile.interests"</span>: <span class="str">"travel"</span> } }
);

<span class="com">// 5. 事务操作（4.0+）</span>
<span class="kwd">const</span> session = db.getMongo().startSession();
session.startTransaction();
<span class="kwd">try</span> {
    session.getDatabase(<span class="str">"shop"</span>).orders.insertOne({ ... });
    session.getDatabase(<span class="str">"shop"</span>).inventory.updateOne({ ... });
    session.commitTransaction();
} <span class="kwd">catch</span> (e) {
    session.abortTransaction();
}</code></pre>
                </div>
                
                <h4>适用场景：</h4>
                <ul>
                    <li>内容管理系统（文章、评论、元数据）</li>
                    <li>用户行为日志和分析</li>
                    <li>物联网（IoT）数据存储</li>
                    <li>敏捷开发，快速迭代的项目</li>
                    <li>需要存储半结构化数据的场景</li>
                </ul>

                <h3>3. Redis - 高速缓存首选</h3>
                <p>Redis是高性能的内存键值数据库，常用作缓存、消息队列和实时分析。</p>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>优点</th>
                                <th>缺点</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>✅ 极高的读写性能（百万级QPS）</td>
                                <td>❌ 数据存储在内存，成本高</td>
                            </tr>
                            <tr>
                                <td>✅ 支持多种数据结构</td>
                                <td>❌ 不适合作为主数据存储</td>
                            </tr>
                            <tr>
                                <td>✅ 丰富的特性（发布订阅、Lua脚本、事务）</td>
                                <td>❌ 持久化可能丢失数据</td>
                            </tr>
                            <tr>
                                <td>✅ 简单易用的客户端</td>
                                <td>❌ 单线程模型（部分场景受限）</td>
                            </tr>
                            <tr>
                                <td>✅ 集群支持</td>
                                <td>❌ 大value性能下降</td>
                            </tr>
                            <tr>
                                <td>✅ 完善的主从复制</td>
                                <td>❌ 需要足够的内存</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com"># Redis 特色操作示例

<span class="com"># 1. 字符串操作</span>
SET user:1001 <span class="str">'{"name":"John","age":30}'</span>
GET user:1001
INCR page:views:2024
DECR product:stock:500

<span class="com"># 2. 哈希操作（存储对象）</span>
HSET user:1001 name John age 30 city Beijing
HGET user:1001 name
HGETALL user:1001

<span class="com"># 3. 列表操作（消息队列）</span>
RPUSH queue:tasks <span class="str">"task1"</span> <span class="str">"task2"</span> <span class="str">"task3"</span>
LPOP queue:tasks
LRANGE queue:tasks 0 -<span class="num">1</span>

<span class="com"># 4. 集合操作（标签、共同好友）</span>
SADD user:1001:tags mysql postgres redis
SADD user:1002:tags mysql python
SINTER user:1001:tags user:1002:tags  <span class="com"># 共同标签</span>

<span class="com"># 5. 有序集合（排行榜）</span>
ZADD leaderboard <span class="num">2500</span> player1 <span class="num">1800</span> player2 <span class="num">3000</span> player3
ZREVRANGE leaderboard 0 9 WITHSCORES
ZINCRBY leaderboard <span class="num">500</span> player1

<span class="com"># 6. 发布/订阅</span>
PSUBSCRIBE news:*
PUBLISH news:sports <span class="str">"New match today!"</span>

<span class="com"># 7. 事务</span>
MULTI
SET key1 value1
SET key2 value2
EXEC

<span class="com"># 8. Lua脚本（原子操作）</span>
EVAL <span class="str">"return redis.call('get', KEYS[1])"</span> <span class="num">1</span> mykey</code></pre>
                </div>
                
                <h4>适用场景：</h4>
                <ul>
                    <li>缓存层（减少数据库压力）</li>
                    <li>会话存储（Session Store）</li>
                    <li>实时排行榜</li>
                    <li>消息队列</li>
                    <li>分布式锁</li>
                    <li>实时分析和计数</li>
                </ul>

                <h3>4. MariaDB - MySQL的最佳替代</h3>
                <p>MariaDB是MySQL的fork，由MySQL原开发者维护，保持高度兼容性。</p>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>优点</th>
                                <th>缺点</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>✅ 完全兼容MySQL，迁移成本低</td>
                                <td>❌ 新特性落后于MySQL企业版</td>
                            </tr>
                            <tr>
                                <td>✅ 更多的存储引擎选择</td>
                                <td>❌ 部分MySQL工具不兼容</td>
                            </tr>
                            <tr>
                                <td>✅ 更好的性能（MyRocks、InnoDB优化）</td>
                                <td>❌ 社区相对较小</td>
                            </tr>
                            <tr>
                                <td>✅ 开源免费，无Oracle控制</td>
                                <td>❌ 企业支持选项较少</td>
                            </tr>
                            <tr>
                                <td>✅ 积极开发新特性</td>
                                <td></td>
                            </tr>
                            <tr>
                                <td>✅ 支持JSON、窗口函数</td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MariaDB 特色功能示例

<span class="com">-- 1. 窗口函数支持</span>
<span class="kwd">SELECT</span> 
    name, department, salary,
    <span class="func">SUM</span>(salary) OVER (<span class="kwd">PARTITION BY</span> department) <span class="kwd">as</span> dept_total
<span class="kwd">FROM</span> employees;

<span class="com">-- 2. JSON支持</span>
<span class="kwd">SELECT</span> JSON_VALUE(info, <span class="str">'$.name'</span>) <span class="kwd">FROM</span> users;

<span class="com">-- 3. 动态列</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> products (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    name <span class="type">VARCHAR</span>(<span class="num">100</span>),
    attributes DYNAMIC
);
INSERT <span class="kwd">INTO</span> products VALUES(<span class="num">1</span>, <span class="str">'Shirt'</span>, COLUMNS(<span class="str">'color'</span>=<span class="str">'red'</span>, <span class="str">'size'</span>=<span class="str">'L'</span>));

<span class="com">-- 4.  Invisible 列</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> users (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    name <span class="type">VARCHAR</span>(<span class="num">50</span>),
    email <span class="type">VARCHAR</span>(<span class="num">100</span>) INVISIBLE
);

<span class="com">-- 5. 并行复制</span>
SET GLOBAL slave_parallel_threads = <span class="num">4</span>;
SET GLOBAL slave_parallel_mode = <span class="str">'optimistic'</span>;

<span class="com">-- 6. 序列引擎</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> seq_1_to_100;</code></pre>
                </div>
                
                <h4>适用场景：</h4>
                <ul>
                    <li>需要从MySQL迁移的项目</li>
                    <li>对MySQL许可证有顾虑的企业</li>
                    <li>需要高性能写入（MyRocks引擎）</li>
                    <li>需要更多存储引擎选择</li>
                </ul>

                <h3>5. TiDB - 分布式NewSQL</h3>
                <p>TiDB是PingCAP开发的分布式NewSQL数据库，兼容MySQL协议，支持水平扩展。</p>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>优点</th>
                                <th>缺点</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>✅ 水平扩展，自动分片</td>
                                <td>❌ 资源消耗较大</td>
                            </tr>
                            <tr>
                                <td>✅ 强一致性（分布式事务）</td>
                                <td>❌ 延迟高于单机数据库</td>
                            </tr>
                            <tr>
                                <td>✅ 兼容MySQL协议和语法</td>
                                <td>❌ 运维复杂度高</td>
                            </tr>
                            <tr>
                                <td>✅ HTAP能力（事务+分析）</td>
                                <td>❌ 学习曲线较陡</td>
                            </tr>
                            <tr>
                                <td>✅ 高可用，自动故障恢复</td>
                                <td>❌ 社区相对较小</td>
                            </tr>
                            <tr>
                                <td>✅ 云原生支持</td>
                                <td>❌ 价格较高</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- TiDB 特色功能示例

<span class="com">-- 1. 自动分片和分布式事务</span>
<span class="kwd">BEGIN</span>;
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> users (name, age) <span class="kwd">VALUES</span>(<span class="str">'John'</span>, <span class="num">30</span>);
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> orders (user_id, amount) <span class="kwd">VALUES</span>(LAST_INSERT_ID(), <span class="num">100</span>);
COMMIT;

<span class="com">-- 2. 智能选择（TiFlash列式存储）</span>
<span class="kwd">SELECT</span> /*+ READ_FROM_STORAGE(tiflash[orders]) */ 
    <span class="func">SUM</span>(amount) <span class="kwd">as</span> total
<span class="kwd">FROM</span> orders
<span class="kwd">WHERE</span> date > <span class="str">'2024-01-01'</span>;

<span class="com">-- 3. 热点小表合并</span>
<span class="kwd">SPLIT</span> <span class="kwd">TABLE</span> users <span class="kwd">BETWEEN</span> (<span class="num">0</span>) <span class="kwd">AND</span> (<span class="num">1000000</span>) REGIONS <span class="num">10</span>;

<span class="com">-- 4. 查看分布式执行计划</span>
EXPLAIN ANALYZE <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> user_id = <span class="num">100</span>;

<span class="com">-- 5. 跨区域复制 (DR 集群)</span>
<span class="com">-- 配置主集群和灾备集群</span>

<span class="com">-- 6. 在线DDL</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users <span class="kwd">ADD</span> COLUMN phone <span class="type">VARCHAR</span>(<span class="num">20</span>);</code></pre>
                </div>
                
                <h4>适用场景：</h4>
                <ul>
                    <li>需要处理海量数据的OLTP场景</li>
                    <li>需要强一致性的分布式事务</li>
                    <li>需要HTAP混合负载</li>
                    <li>云原生架构的中大型企业</li>
                    <li>需要全球化部署的应用</li>
                </ul>

                <h3>6. SQL Server - 企业级选择</h3>
                <p>Microsoft SQL Server是企业级关系型数据库，与Windows生态深度集成。</p>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>优点</th>
                                <th>缺点</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>✅ 完整的商业支持和服务</td>
                                <td>❌ 许可证费用高</td>
                            </tr>
                            <tr>
                                <td>✅ 与.NET生态完美集成</td>
                                <td>❌ 仅支持Windows（Linux版本功能有限）</td>
                            </tr>
                            <tr>
                                <td>✅ 强大的BI和分析功能</td>
                                <td>❌ 开源支持有限</td>
                            </tr>
                            <tr>
                                <td>✅ 优秀的性能调优工具</td>
                                <td>❌ 资源消耗大</td>
                            </tr>
                            <tr>
                                <td>✅ 完善的备份恢复方案</td>
                                <td>❌ 迁移到其他数据库困难</td>
                            </tr>
                            <tr>
                                <td>✅ Always On高可用</td>
                                <td></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <h4>适用场景：</h4>
                <ul>
                    <li>使用.NET技术栈的企业应用</li>
                    <li>需要完整商业支持的大型企业</li>
                    <li>需要强大BI和报表功能</li>
                    <li>微软技术生态的现有系统</li>
                </ul>

                <h3>数据库选择决策指南</h3>
                
                <div class="mermaid">
flowchart TD
    A([选择数据库]) --> B{数据模型?}
    B -->|结构化| C{一致性要求?}
    B -->|半结构化| D[MongoDB]
    B -->|键值/缓存| E[Redis]
    
    C -->|强一致| F{数据规模?}
    C -->|最终一致| G[MySQL/PostgreSQL]
    
    F -->|小规模| H[MySQL/PostgreSQL]
    F -->|中等规模| I[MariaDB]
    F -->|大规模| J[TiDB/云数据库]
    
    K{需要分析?} -->|是| L[ClickHouse/StarRocks]
    K -->|否| M([继续开发])
    
    style A fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style D fill:#c8e6c9,stroke:#2e7d32
    style E fill:#fff3e0,stroke:#e65100
    style J fill:#fce4ec,stroke:#c2185b
    style L fill:#e1f5fe,stroke:#01579b
    style M fill:#c8e6c9,stroke:#2e7d32
</div>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>业务场景</th>
                                <th>推荐数据库</th>
                                <th>原因</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>博客/CMS网站</td>
                                <td>MySQL + Redis</td>
                                <td>成熟稳定，生态丰富</td>
                            </tr>
                            <tr>
                                <td>电商平台</td>
                                <td>MySQL/PostgreSQL</td>
                                <td>事务支持，ACID</td>
                            </tr>
                            <tr>
                                <td>金融系统</td>
                                <td>PostgreSQL/TiDB/Oracle</td>
                                <td>强一致性，分布式</td>
                            </tr>
                            <tr>
                                <td>社交网络</td>
                                <td>MongoDB + Redis</td>
                                <td>灵活Schema，高并发</td>
                            </tr>
                            <tr>
                                <td>数据分析</td>
                                <td>ClickHouse/StarRocks</td>
                                <td>列式存储，OLAP</td>
                            </tr>
                            <tr>
                                <td>实时大屏</td>
                                <td>Redis + ClickHouse</td>
                                <td>高速读写+分析</td>
                            </tr>
                            <tr>
                                <td>物联网</td>
                                <td>InfluxDB/TimescaleDB</td>
                                <td>时序数据优化</td>
                            </tr>
                            <tr>
                                <td>SaaS应用</td>
                                <td>PostgreSQL</td>
                                <td>多租户，JSON支持</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <section id="history" class="section">
            <h2>MySQL 发展历程</h2>
            <div class="content">
                <p>MySQL 由瑞典 MySQL AB 公司开发，于 2008 年被 Sun Microsystems 收购，2009 年随 Sun 被 Oracle 收购。作为最流行的开源关系型数据库，MySQL 经历了多个重要版本的迭代，每个版本都带来了关键的新特性和性能提升。</p>
                
                <div class="mermaid">
gantt
    title MySQL 版本演进时间线
    dateFormat YYYY
    axisFormat %Y
    section 早期
    MySQL 1.0 诞生         :1995-01-01, 0d
    MySQL 3.23 发布       :2000-01-01, 0d
    section 发展
    MySQL 4.0 发布        :2003-01-01, 0d
    MySQL 5.0 发布        :2005-01-01, 0d
    MySQL 5.5 发布        :2010-01-01, 0d
    MySQL 5.6 发布        :2013-01-01, 0d
    MySQL 5.7 发布        :2015-01-01, 0d
    section 现代
    MySQL 8.0 发布        :2018-01-01, 0d
    MySQL 8.4 LTS         :2024-04-01, 0d
    MySQL 9.0 发布        :2024-10-01, 0d
</div>
                
                <h3>1. MySQL 3.23 (2000年) - 奠定基础</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MySQL 3.23 是首个广泛使用的稳定版本</span>

<span class="com">-- 主要特性：</span>
<span class="com">-- 1. 引入 MyISAM 存储引擎 (取代 ISAM)</span>
<span class="com">-- 2. 支持 FULLTEXT 全文索引</span>
<span class="com">-- 3. 首次支持事务 (通过 BerkeleyDB 引擎)</span>
<span class="com">-- 4. 复制功能正式推出</span>
<span class="com">-- 5. 支持 ANSI SQL99 语法</span>

<span class="com">-- 解决的问题：</span>
<span class="com">-- - 早期版本功能简单，无法满足复杂应用需求</span>
<span class="com">-- - 缺乏全文搜索能力</span>
<span class="com">-- - 没有复制功能，无法实现高可用</span>

<span class="com">-- 创建 MyISAM 表并使用全文索引</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> articles (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    title <span class="type">VARCHAR</span>(<span class="num">200</span>),
    content <span class="type">TEXT</span>,
    <span class="kwd">FULLTEXT</span> <span class="kwd">INDEX</span> ft_title_content (title, content)
) ENGINE=MyISAM;

<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> articles
<span class="kwd">WHERE</span> <span class="func">MATCH</span>(title, content) <span class="func">AGAINST</span>(<span class="str">'MySQL'</span> <span class="kwd">IN</span> <span class="kwd">NATURAL</span> <span class="kwd">LANGUAGE</span> MODE);</code></pre>
                </div>

                <h3>2. MySQL 4.0 - 性能飞跃</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MySQL 4.0 (2003年) 是里程碑版本</span>

<span class="com">-- 主要特性：</span>
<span class="com">-- 1. 引入 InnoDB 存储引擎 (事务支持)</span>
<span class="com">-- 2. 查询缓存 (Query Cache) 大幅提升性能</span>
<span class="com">-- 3. 支持 UNION 语句</span>
<span class="com">-- 4. 支持 RENAME TABLE</span>
<span class="com">-- 5. 改进了 BLOB 类型的处理</span>

<span class="com">-- 解决的问题：</span>
<span class="com">-- - MyISAM 不支持事务，无法保证数据一致性</span>
<span class="com">-- - 重复查询浪费资源，查询缓存解决此问题</span>
<span class="com">-- - 无法进行复杂的 SQL 查询</span>

<span class="com">-- 使用 InnoDB 引擎和事务</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> accounts (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    balance <span class="type">DECIMAL</span>(<span class="num">15</span>,<span class="num">2</span>)
) ENGINE=InnoDB;

START TRANSACTION;
<span class="kwd">UPDATE</span> accounts <span class="kwd">SET</span> balance = balance - <span class="num">100</span> <span class="kwd">WHERE</span> id = <span class="num">1</span>;
<span class="kwd">UPDATE</span> accounts <span class="kwd">SET</span> balance = balance + <span class="num">100</span> <span class="kwd">WHERE</span> id = <span class="num">2</span>;
COMMIT;

<span class="com">-- 查看查询缓存状态</span>
SHOW VARIABLES LIKE <span class="str">'query_cache_type'</span>;</code></pre>
                </div>

                <h3>3. MySQL 5.0 - 企业级功能</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MySQL 5.0 (2005年) 正式进入企业级市场</span>

<span class="com">-- 主要特性：</span>
<span class="com">-- 1. 存储过程 (Stored Procedures)</span>
<span class="com">-- 2. 触发器 (Triggers)</span>
<span class="com">-- 3. 视图 (Views)</span>
<span class="com">-- 4. 游标 (Cursors)</span>
<span class="com">-- 5. INFORMATION_SCHEMA 系统数据库</span>
<span class="com">-- 6. 支持XA事务</span>

<span class="com">-- 解决的问题：</span>
<span class="com">-- - 缺少存储过程，复杂业务逻辑需在应用层实现</span>
<span class="com">-- - 缺乏触发器，无法实现自动化数据维护</span>
<span class="com">-- - 无法创建视图，复杂查询无法封装</span>

<span class="com">-- 创建存储过程</span>
<span class="kwd">DELIMITER</span> //
<span class="kwd">CREATE</span> <span class="kwd">PROCEDURE</span> get_user_count()
<span class="kwd">BEGIN</span>
    <span class="kwd">SELECT</span> <span class="func">COUNT</span>(*) <span class="kwd">as</span> total_users <span class="kwd">FROM</span> users;
<span class="kwd">END</span> //
<span class="kwd">DELIMITER</span> ;

<span class="kwd">CALL</span> get_user_count();

<span class="com">-- 创建触发器</span>
<span class="kwd">DELIMITER</span> //
<span class="kwd">CREATE</span> <span class="kwd">TRIGGER</span> before_insert_users
<span class="kwd">BEFORE</span> <span class="kwd">INSERT</span> <span class="kwd">ON</span> users
<span class="kwd">FOR EACH ROW</span>
<span class="kwd">BEGIN</span>
    <span class="kwd">SET</span> NEW.created_at = <span class="kwd">NOW</span>();
<span class="kwd">END</span> //
<span class="kwd">DELIMITER</span> ;

<span class="com">-- 创建视图</span>
<span class="kwd">CREATE</span> <span class="kwd">VIEW</span> user_stats <span class="kwd">AS</span>
<span class="kwd">SELECT</span> 
    <span class="kwd">COUNT</span>(*) <span class="kwd">as</span> total,
    <span class="func">AVG</span>(age) <span class="kwd">as</span> avg_age
<span class="kwd">FROM</span> users;</code></pre>
                </div>

                <h3>4. MySQL 5.5 - 稳定与性能</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MySQL 5.5 (2010年) 成为主流稳定版本</span>

<span class="com">-- 主要特性：</span>
<span class="com">-- 1. InnoDB 成为默认存储引擎</span>
<span class="com">-- 2. 半同步复制 (Semi-Synchronous Replication)</span>
<span class="com">-- 3. 改进的分区表功能</span>
<span class="com">-- 4.  SIGNAL 和 RESIGNAL 语句 (错误处理)</span>
<span class="com">-- 5. 改进了 UTF-8 支持 (utf8mb4)</span>
<span class="com">-- 6. 多核 CPU 性能优化</span>

<span class="com">-- 解决的问题：</span>
<span class="com">-- - MyISAM 不支持并发写入和数据恢复</span>
<span class="com">-- - 复制延迟高，数据一致性无法保证</span>
<span class="com">-- - UTF-8 只支持3字节，中文emoji受限</span>

<span class="com">-- 启用半同步复制 (需要安装插件)</span>
INSTALL PLUGIN rpl_semi_sync_master SONAME <span class="str">'semisync_master.so'</span>;
INSTALL PLUGIN rpl_semi_sync_slave SONAME <span class="str">'semisync_slave.so'</span>;

SET GLOBAL rpl_semi_sync_master_enabled = <span class="num">1</span>;
SET GLOBAL rpl_semi_sync_slave_enabled = <span class="num">1</span>;

<span class="com">-- 使用 utf8mb4 字符集</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> messages (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    content <span class="type">VARCHAR</span>(<span class="num">1000</span>) <span class="kwd">CHARSET</span> utf8mb4 COLLATE utf8mb4_unicode_ci
) ENGINE=InnoDB;

<span class="com">-- 分区表示例</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> logs (
    id <span class="kwd">INT</span>,
    log_date <span class="type">DATETIME</span>,
    message <span class="type">TEXT</span>
) ENGINE=InnoDB
<span class="kwd">PARTITION</span> <span class="kwd">BY</span> RANGE (YEAR(log_date)) (
    <span class="kwd">PARTITION</span> p2023 <span class="kwd">VALUES</span> LESS THAN (<span class="num">2024</span>),
    <span class="kwd">PARTITION</span> p2024 <span class="kwd">VALUES</span> LESS THAN (<span class="num">2025</span>),
    <span class="kwd">PARTITION</span> pfuture <span class="kwd">VALUES</span> LESS THAN MAXVALUE
);</code></pre>
                </div>

                <h3>5. MySQL 5.6 - 大数据时代</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MySQL 5.6 (2013年) 适配大数据场景</span>

<span class="com">-- 主要特性：</span>
<span class="com">-- 1. 索引下推优化 (Index Condition Pushdown)</span>
<span class="com">-- 2. MRR (Multi-Range Read) 优化</span>
<span class="com">-- 3. 全文索引支持 InnoDB</span>
<span class="com">-- 4. 实时监控 InnoDB 性能</span>
<span class="com">-- 5. 改进的优化器</span>
<span class="com">-- 6. 延迟复制 (Delayed Replication)</span>

<span class="com">-- 解决的问题：</span>
<span class="com">-- - 大表查询性能差</span>
<span class="com">-- - InnoDB 不支持全文索引</span>
<span class="com">-- - 误操作无法快速恢复</span>

<span class="com">-- EXPLAIN 查看执行计划</span>
EXPLAIN <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span>;

<span class="com">-- InnoDB 全文索引</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> articles (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    title <span class="type">VARCHAR</span>(<span class="num">200</span>),
    content <span class="type">TEXT</span>,
    <span class="kwd">FULLTEXT</span> <span class="kwd">INDEX</span> ft_content (content)
) ENGINE=InnoDB;

<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> articles
<span class="kwd">WHERE</span> <span class="func">MATCH</span>(content) <span class="func">AGAINST</span>(<span class="str">'database'</span> <span class="kwd">IN</span> <span class="kwd">NATURAL</span> <span class="kwd">LANGUAGE</span> MODE);

<span class="com">-- 延迟复制 (延迟10分钟)</span>
STOP SLAVE;
CHANGE MASTER TO MASTER_DELAY = <span class="num">600</span>;
START SLAVE;

<span class="com">-- 监控 InnoDB 状态</span>
SHOW ENGINE InnoDB STATUS;

<span class="com">-- 查看慢查询</span>
SHOW VARIABLES LIKE <span class="str">'slow_query_log'</span>;
SHOW VARIABLES LIKE <span class="str">'long_query_time'</span>;</code></pre>
                </div>

                <h3>6. MySQL 5.7 - JSON 时代</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MySQL 5.7 (2015年) 原生支持 JSON</span>

<span class="com">-- 主要特性：</span>
<span class="com">-- 1. 原生 JSON 数据类型和函数</span>
<span class="com">-- 2. 虚拟列 (Generated Columns)</span>
<span class="com">-- 3. 多源复制 (Multi-Source Replication)</span>
<span class="com">-- 4. 改进的 GIS 地理位置支持</span>
<span class="com">-- 5. 增强的 InnoDB 性能</span>
<span class="com">-- 6. Sys schema 系统监控视图</span>
<span class="com">-- 7. 支持 JSON 索引 (通过虚拟列)</span>

<span class="com">-- 解决的问题：</span>
<span class="com">-- - NoSQL 数据库冲击，需支持灵活 schema</span>
<span class="com">-- - JSON 数据存储和查询困难</span>
<span class="com">-- - 需要从多个数据源聚合数据</span>

<span class="com">-- JSON 数据类型</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> user_configs (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    user_id <span class="kwd">INT</span>,
    config <span class="type">JSON</span>
);

<span class="kwd">INSERT</span> <span class="kwd">INTO</span> user_configs (user_id, config)
<span class="kwd">VALUES</span>(<span class="num">1</span>, <span class="str">'{"theme": "dark", "notifications": true, "language": "zh"}'</span>);

<span class="kwd">SELECT</span> 
    user_id,
    config->><span class="str">'$.theme'</span> <span class="kwd">as</span> theme
<span class="kwd">FROM</span> user_configs;

<span class="kwd">SELECT</span> <span class="func">JSON_EXTRACT</span>(config, <span class="str">'$.notifications'</span>) <span class="kwd">FROM</span> user_configs;

<span class="com">-- 虚拟列索引</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> products (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    specs <span class="type">JSON</span>,
    price <span class="type">INT</span>,
    category <span class="type">VARCHAR</span>(<span class="num">50</span>) <span class="kwd">GENERATED</span> ALWAYS <span class="kwd">AS</span> (specs->><span class="str">'$.category'</span>) STORED,
    <span class="kwd">INDEX</span> idx_category (category)
);

<span class="com">-- GIS 地理位置</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> locations (
    id <span class="kwd">INT</span>,
    name <span class="type">VARCHAR</span>(<span class="num">100</span>),
    location POINT,
    <span class="kwd">SPATIAL</span> <span class="kwd">INDEX</span> (location)
) ENGINE=InnoDB;

<span class="kwd">INSERT</span> <span class="kwd">INTO</span> locations <span class="kwd">VALUES</span>(<span class="num">1</span>, <span class="str">'天安门'</span>, <span class="func">ST_GeomFromText</span>(<span class="str">'POINT(116.397 39.909)'</span>));</code></pre>
                </div>

                <h3>7. MySQL 8.0 - 全面进化</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MySQL 8.0 (2018年) 里程碑版本</span>

<span class="com">-- 主要特性：</span>
<span class="com">-- 1. 窗口函数 (Window Functions)</span>
<span class="com">-- 2. 公共表表达式 (CTE / WITH RECURSIVE)</span>
<span class="com">-- 3. 隐藏索引 (Invisible Indexes)</span>
<span class="com">-- 4. 降序索引 (Descending Indexes)</span>
<span class="com">-- 5. 角色 (Roles) 权限管理</span>
<span class="com">-- 6. 改进了 JSON 函数</span>
<span class="com">-- 7. 支持 UTF8MB4 字符集默认</span>
<span class="com">-- 8. 增强的 GIS 功能 (GeoJSON)</span>
<span class="com">-- 9. 字典数据 (Data Dictionary)</span>

<span class="com">-- 解决的问题：</span>
<span class="com">-- - 复杂分析查询需要 UNION，效率低</span>
<span class="com">-- - 递归查询需要程序模拟</span>
<span class="com">-- - 无法在线测试索引效果</span>
<span class="com">-- - 权限管理不够灵活</span>

<span class="com">-- 窗口函数</span>
<span class="kwd">SELECT</span> 
    name,
    department,
    salary,
    <span class="func">RANK</span>() OVER (<span class="kwd">PARTITION BY</span> department <span class="kwd">ORDER BY</span> salary DESC) <span class="kwd">as</span> dept_rank,
    <span class="func">SUM</span>(salary) OVER (<span class="kwd">ORDER BY</span> salary) <span class="kwd">as</span> running_total
<span class="kwd">FROM</span> employees;

<span class="com">-- 递归 CTE (查询组织架构)</span>
<span class="kwd">WITH</span> <span class="kwd">RECURSIVE</span> org_tree <span class="kwd">AS</span> (
    <span class="kwd">SELECT</span> id, name, manager_id, <span class="num">1</span> <span class="kwd">as</span> <span class="kwd">level</span>
    <span class="kwd">FROM</span> employees <span class="kwd">WHERE</span> manager_id <span class="kwd">IS</span> NULL
    <span class="kwd">UNION ALL</span>
    <span class="kwd">SELECT</span> e.id, e.name, e.manager_id, ot.<span class="kwd">level</span> + <span class="num">1</span>
    <span class="kwd">FROM</span> employees e
    <span class="kwd">JOIN</span> org_tree ot <span class="kwd">ON</span> e.manager_id = ot.id
)
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> org_tree;

<span class="com">-- 隐藏索引测试</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_test <span class="kwd">ON</span> users(email) INVISIBLE;
<span class="kwd">ALTER</span> <span class="kwd">INDEX</span> idx_test VISIBLE;

<span class="com">-- 角色权限管理</span>
<span class="kwd">CREATE</span> <span class="kwd">ROLE</span> <span class="str">'app_read'</span>, <span class="str">'app_write'</span>;
GRANT SELECT <span class="kwd">ON</span> mydb.* <span class="kwd">TO</span> <span class="str">'app_read'</span>;
GRANT INSERT, UPDATE, DELETE <span class="kwd">ON</span> mydb.* <span class="kwd">TO</span> <span class="str">'app_write'</span>;
GRANT <span class="str">'app_read'</span>, <span class="str">'app_write'</span> <span class="kwd">TO</span> <span class="str">'user1'</span>@<span class="str">'localhost'</span>;
SET DEFAULT ROLE <span class="str">'app_read'</span> <span class="kwd">FOR</span> <span class="str">'user1'</span>@<span class="str">'localhost'</span>;</code></pre>
                </div>

                <h3>8. MySQL 8.4 LTS - 长期支持</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MySQL 8.4 (2024年4月) LTS 长期支持版本</span>

<span class="com">-- 主要特性：</span>
<span class="com">-- 1. 性能提升 (InnoDB 引擎优化)</span>
<span class="com">-- 2. JSON 数组增强</span>
<span class="com">-- 3. 改进的复制功能</span>
<span class="com">-- 4. 增强的安全特性</span>
<span class="com">-- 5. 更好的 UTF-8 支持 (UTF8MB4 改进)</span>
<span class="com">-- 6. 窗口函数性能优化</span>
<span class="com">-- 7. 改进的审计日志</span>

<span class="com">-- 解决的问题：</span>
<span class="com">-- - 企业需要稳定可靠的长期支持版本</span>
<span class="com">-- - JSON 处理效率需要提升</span>
<span class="com">-- - 需要更好的安全合规性</span>

<span class="com">-- 查看版本信息</span>
SELECT VERSION();
SHOW VARIABLES LIKE <span class="str">'version_comment'</span>;

<span class="com">-- JSON 数组函数增强</span>
<span class="kwd">SELECT</span> <span class="func">JSON_ARRAYAGG</span>(column) <span class="kwd">FROM</span> table;
<span class="kwd">SELECT</span> <span class="func">JSON_OBJECTAGG</span>(key, value) <span class="kwd">FROM</span> table;

<span class="com">-- 检查字符集</span>
SHOW VARIABLES LIKE <span class="str">'character_set%'</span>;
SHOW VARIABLES LIKE <span class="str">'collation%'</span>;</code></pre>
                </div>

                <h3>9. MySQL 9.0 - AI 时代</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MySQL 9.0 (2024年) 最新版本</span>

<span class="com">-- 主要特性：</span>
<span class="com">-- 1. 原生向量数据类型 (Vector Type)</span>
<span class="com">-- 2. AI 查询优化器 (AI Query Optimizer)</span>
<span class="com">-- 3. HNSW 索引支持向量搜索</span>
<span class="com">-- 4. JavaScript 存储过程</span>
<span class="com">-- 5. LATERAL JOIN 支持</span>
<span class="com">-- 6. 物化视图 (Materialized Views)</span>
<span class="com">-- 7. 增强的 JSON 处理</span>
<span class="com">-- 8. 更好的云原生支持</span>
<span class="com">-- 9. ARM64 架构优化</span>

<span class="com">-- 解决的问题：</span>
<span class="com">-- - AI/ML 应用需要向量数据库能力</span>
<span class="com">-- - 传统 SQL 无法高效处理向量相似性搜索</span>
<span class="com">-- - 需要更智能的查询优化</span>

<span class="com">-- 向量数据类型</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> embeddings (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    doc_text <span class="type">TEXT</span>,
    vector VECTOR(<span class="num">768</span>),
    <span class="kwd">INDEX</span> idx_vector (vector) <span class="kwd">INDEX_TYPE</span> = <span class="str">'HNSW'</span>
);

<span class="com">-- 向量相似性搜索</span>
<span class="kwd">SELECT</span> id, doc_text,
    <span class="func">VECTOR_DISTANCE</span>(vector, <span class="str">'[0.1, 0.2, ...]'</span>, <span class="str">'cosine'</span>) <span class="kwd">as</span> distance
<span class="kwd">FROM</span> embeddings
<span class="kwd">ORDER BY</span> distance
<span class="kwd">LIMIT</span> <span class="num">5</span>;

<span class="com">-- JavaScript 存储过程</span>
<span class="kwd">DELIMITER</span> //
<span class="kwd">CREATE</span> <span class="kwd">PROCEDURE</span> analyze_data()
<span class="kwd">LANGUAGE</span> <span class="kwd">JAVASCRIPT</span> <span class="kwd">AS</span>
$$
    var result = session.sql(<span class="str">'SELECT COUNT(*) FROM users'</span>).execute();
    return <span class="str">'Total users: '</span> + result.fetchOne()[<span class="num">0</span>];
$$ //
<span class="kwd">DELIMITER</span> ;

<span class="com">-- 物化视图</span>
<span class="kwd">CREATE</span> <span class="kwd">MATERIALIZED</span> <span class="kwd">VIEW</span> sales_summary
REFRESH <span class="kwd">EVERY</span> <span class="num">1</span> <span class="kwd">HOUR</span> <span class="kwd">AS</span>
<span class="kwd">SELECT</span> 
    <span class="func">DATE</span>(order_date) <span class="kwd">as</span> date,
    <span class="func">COUNT</span>(*) <span class="kwd">as</span> total_orders,
    <span class="func">SUM</span>(amount) <span class="kwd">as</span> total_amount
<span class="kwd">FROM</span> orders
<span class="kwd">GROUP BY</span> <span class="func">DATE</span>(order_date);

<span class="com">-- LATERAL JOIN</span>
<span class="kwd">SELECT</span> u.name, latest_orders.*
<span class="kwd">FROM</span> users u
<span class="kwd">LEFT JOIN</span> <span class="kwd">LATERAL</span> (
    <span class="kwd">SELECT</span> order_id, total
    <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> user_id = u.id
    <span class="kwd">ORDER BY</span> order_date DESC LIMIT <span class="num">3</span>
) <span class="kwd">AS</span> latest_orders <span class="kwd">ON</span> TRUE;

<span class="com">-- AI 优化提示</span>
<span class="kwd">SELECT</span> /*+ AI_OPTIMIZE */ * <span class="kwd">FROM</span> large_table
<span class="kwd">WHERE</span> complex_condition = <span class="num">1</span>;</code></pre>
                </div>

                <h3>版本选择建议</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 版本选择指南</span>

<span class="com">-- 生产环境推荐：</span>
<span class="com">-- - MySQL 8.4 LTS: 稳定可靠，适合长期项目</span>
<span class="com">-- - MySQL 8.0.35+: 如果需要窗口函数/CTE</span>
<span class="com">-- - MySQL 5.7: 遗留系统维护 (不推荐新项目)</span>

<span class="com">-- 开发/测试环境：</span>
<span class="com">-- - MySQL 9.x: 测试最新特性，为迁移做准备</span>

<span class="com">-- 需要向量搜索/AI 应用：</span>
<span class="com">-- - MySQL 9.0+</span>

<span class="com">-- 查看当前版本</span>
SELECT 
    @@version <span class="kwd">as</span> version,
    @@version_comment <span class="kwd">as</span> edition;

<span class="com">-- 检查支持的特性</span>
SHOW VARIABLES LIKE <span class="str">'have_%'</span>;
SHOW ENGINES;</code></pre>
                </div>
            </div>
        </section>

        <section id="installation" class="section">
            <h2>安装 MySQL 9.x (最新版本)</h2>
            <div class="content">
                <h3>版本选择指南</h3>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>版本</th>
                                <th>类型</th>
                                <th>适用场景</th>
                                <th>推荐程度</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>MySQL 9.x</td>
                                <td>创新版</td>
                                <td>AI/ML应用、向量搜索、新项目测试</td>
                                <td>⭐⭐⭐⭐</td>
                            </tr>
                            <tr>
                                <td>MySQL 8.4</td>
                                <td>LTS (长期支持)</td>
                                <td>生产环境首选，稳定可靠</td>
                                <td>⭐⭐⭐⭐⭐</td>
                            </tr>
                            <tr>
                                <td>MySQL 8.0</td>
                                <td>标准版</td>
                                <td>需要窗口函数/CTE的项目</td>
                                <td>⭐⭐⭐⭐</td>
                            </tr>
                            <tr>
                                <td>MySQL 5.7</td>
                                <td>遗留版</td>
                                <td>仅用于遗留系统维护</td>
                                <td>⭐⭐</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <p><strong>MySQL 9.x 新特性：</strong></p>
                <ul>
                    <li>• 原生支持 ARM64 架构优化</li>
                    <li>• 集成 AI 查询优化器</li>
                    <li>• 改进的 JSON 处理能力</li>
                    <li>• 更好的云原生支持</li>
                    <li>• 增强的安全性功能</li>
                </ul>
                <div class="tabs">
                    <div class="tab-buttons">
                        <span class="tab-button">Mac 系统 (ARM64)</span>
                        <span class="tab-button">Linux 系统</span>
                        <span class="tab-button">Windows 系统</span>
                        <span class="tab-button">Docker</span>
                    </div>

                    <div class="tab-content" id="mac">
                        <pre><code class="sh"><span class="com"># 使用 Homebrew 安装 MySQL 9.x</span>
<span class="cmd">brew</span> install mysql@<span class="num">9</span>.<span class="num">0</span>

<span class="com"># 启动 MySQL 服务</span>
<span class="cmd">brew</span> <span class="cmd">services</span> start mysql@<span class="num">9</span>.<span class="num">0</span>

<span class="com"># 安全配置（支持多因素认证）</span>
<span class="cmd">mysql_secure_installation</span> --mfa

<span class="com"># 验证安装</span>
<span class="cmd">mysql</span> --<span class="cmd">version</span>

<span class="com"># 登录 MySQL</span>
<span class="cmd">mysql</span> -u root -p</code></pre>
                    </div>

                    <div class="tab-content" id="linux">
                        <pre><code class="sh"><span class="str">"com"</span>><span class="com"># Ubuntu/Debian 24.04 LTSsudoapt updatesudoapt install mysql-server-9.0</span>

<span class="str">"com"</span>><span class="com"># 启用 AI 优化器</span>
sudomysql -e <span class="str">"SET GLOBAL optimizer_switch=ai_optimization=on;"</span>

<span class="str">"com"</span>><span class="com"># 启动服务</span>
sudosystemctl startmysql
sudosystemctl enablemysql

<span class="str">"com"</span>><span class="com"># RHEL/CentOS 9sudodnf install mysql-server</span>

<span class="str">"com"</span>><span class="com"># 安全配置</span>
sudomysql_secure_installation</code></pre>
                    </div>

                    <div class="tab-content" id="windows">
                        <pre><code class="sh"><span class="str">"com"</span>><span class="com"># 1. 访问 MySQL 官网下载 MySQL 9.x</span>
<span class="str">"com"</span>><span class="com"># https://dev.mysql.com/downloads/mysql/</span>

<span class="str">"com"</span>><span class="com"># 2. 选择 "Developer Default" 安装类型</span>

<span class="str">"com"</span>><span class="com"># 3. 启用以下选项：</span>
<span class="str">"com"</span>><span class="com">#    - AI Query Optimizer</span>
<span class="str">"com"</span>><span class="com">#    - Machine Learning Integration</span>
<span class="str">"com"</span>><span class="com">#    - Enhanced Security</span>

<span class="str">"com"</span>><span class="com"># 4. 配置 root 密码（支持密码策略）</span>

<span class="str">"com"</span>><span class="com"># 5. 启动 MySQL 服务</span>
<span class="str">"com"</span>><span class="com"># 从开始菜单运行 "MySQL 9.0 Command Line Client"</span></code></pre>
                    </div>

                    <div class="tab-content" id="docker">
                        <pre><code class="sh"><span class="str">"com"</span>><span class="com"># 拉取最新 MySQL 9.x 镜像docker pull mysql:9.0</span>

<span class="str">"com"</span>><span class="com"># 运行容器（启用 AI 优化器）docker run --name mysql90 \</span>
  -p <span class="num">3306</span>:<span class="num">3306</span> \
  -e MYSQL_ROOT_PASSWORD=yourpassword \
  -e MYSQL_AI_OPTIMIZER=<span class="num">1</span> \
  -d mysql:<span class="num">9</span>.<span class="num">0</span>

<span class="str">"com"</span>><span class="com"># 连接到容器dockerexec -it mysql90mysql -u root -p</span>

<span class="str">"com"</span>><span class="com"># 使用 Docker Compose</span>
version: <span class="num">3</span>.<span class="num">8</span>
services:
  mysql:
    image: mysql:<span class="num">9</span>.<span class="num">0</span>
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_AI_OPTIMIZER: <span class="num">1</span>
    ports:
      - <span class="str">"<span class="num">3306</span>:<span class="num">3306</span>"</span>
    volumes:
      - mysql_data:/var/lib/<span class="cmd">mysql</span>

volumes:
  mysql_data:</code></pre>
                    </div>
                </div>
            </div>
        </section>

        <section id="basics" class="section">
            <h2>基础操作</h2>
            <div class="content">
                <h3>SQL 语句分类</h3>
                <p>SQL（Structured Query Language）是一种用于管理关系数据库的标准计算机语言。根据功能可分为以下几类：</p>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>分类</th>
                                <th>关键字</th>
                                <th>功能说明</th>
                                <th>示例</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>DDL</strong></td>
                                <td>CREATE, DROP, ALTER, TRUNCATE</td>
                                <td>定义数据库对象（表、索引、视图等）</td>
                                <td>CREATE TABLE, ALTER TABLE</td>
                            </tr>
                            <tr>
                                <td><strong>DML</strong></td>
                                <td>INSERT, UPDATE, DELETE</td>
                                <td>操作数据（增、删、改）</td>
                                <td>INSERT INTO, UPDATE, DELETE</td>
                            </tr>
                            <tr>
                                <td><strong>DQL</strong></td>
                                <td>SELECT</td>
                                <td>查询数据</td>
                                <td>SELECT * FROM users</td>
                            </tr>
                            <tr>
                                <td><strong>DCL</strong></td>
                                <td>GRANT, REVOKE</td>
                                <td>控制用户权限</td>
                                <td>GRANT SELECT ON db</td>
                            </tr>
                            <tr>
                                <td><strong>TCL</strong></td>
                                <td>COMMIT, ROLLBACK, SAVEPOINT</td>
                                <td>事务控制</td>
                                <td>COMMIT, ROLLBACK</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <h3>1. 连接数据库</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 连接到 MySQL</span>
mysql -u root -p

<span class="com">-- 或指定主机和端口</span>
mysql -h localhost -P <span class="num">3306</span> -u root -p</code></pre>
                </div>

                <h3>2. 创建数据库</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 创建数据库</span>
<span class="kwd">CREATE</span> <span class="kwd">DATABASE</span> my_database;

<span class="com">-- 显示所有数据库</span>
<span class="kwd">SHOW</span> DATABASES;

<span class="com">-- 使用指定数据库</span>
<span class="kwd">USE</span> my_database;

<span class="com">-- 删除数据库</span>
<span class="kwd">DROP</span> <span class="kwd">DATABASE</span> my_database;</code></pre>
                </div>

                <h3>3. 创建数据表（支持新数据类型）</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 创建用户表（包含 <span class="kwd">JSON</span> 和 <span class="kwd">VECTOR</span> 类型）</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> users (
    id <span class="kwd">BIGINT</span> <span class="kwd">UNSIGNED</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    username <span class="type">VARCHAR</span>(<span class="num">100</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span> <span class="kwd">UNIQUE</span>,
    email <span class="type">VARCHAR</span>(<span class="num">255</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    age <span class="kwd">TINYINT</span> <span class="kwd">UNSIGNED</span>,
    preferences <span class="type">JSON</span>,
    user_embedding <span class="type">VECTOR</span>(<span class="num">768</span>),
    created_at <span class="type">TIMESTAMP</span>(<span class="num">6</span>) <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>(<span class="num">6</span>),
    updated_at <span class="type">TIMESTAMP</span>(<span class="num">6</span>) <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>(<span class="num">6</span>) <span class="kwd">ON</span> <span class="kwd">UPDATE</span> <span class="kwd">CURRENT_TIMESTAMP</span>(<span class="num">6</span>),
    <span class="kwd">FULLTEXT</span> <span class="kwd">INDEX</span> idx_username_fulltext (username),
    <span class="kwd">INDEX</span> idx_email (email),
    <span class="kwd">SPATIAL</span> <span class="kwd">INDEX</span> idx_location (location) <span class="kwd">IF</span> <span class="kwd">EXISTS</span>
) ENGINE=InnoDB <span class="kwd">DEFAULT</span> CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

<span class="com">-- 查看表结构</span>
<span class="kwd">DESCRIBE</span> users;
<span class="kwd">SHOW</span> <span class="kwd">CREATE</span> <span class="kwd">TABLE</span> users\G</code></pre>
                </div>

                <h3>4. 插入数据</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 插入单条数据</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> users (username, email, age)
<span class="kwd">VALUES</span> (<span class="str">'zhangsan'</span>, <span class="str">'zhangsan@example.com'</span>, <span class="num">25</span>);

<span class="com">-- 插入多条数据</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> users (username, email, age) <span class="kwd">VALUES</span>
    (<span class="str">'lisi'</span>, <span class="str">'lisi@example.com'</span>, <span class="num">30</span>),
    (<span class="str">'wangwu'</span>, <span class="str">'wangwu@example.com'</span>, <span class="num">28</span>);</code></pre>
                </div>

                <h3>5. 查询数据（使用 AI 优化）</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 查询所有数据</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users;

<span class="com">-- 查询特定列</span>
<span class="kwd">SELECT</span> username, email <span class="kwd">FROM</span> users;

<span class="com">-- 条件查询（<span class="kwd">AI</span> 自动优化）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span>;

<span class="com">-- <span class="kwd">JSON</span> 数据查询</span>
<span class="kwd">SELECT</span> username,
       <span class="func">JSON_EXTRACT</span>(preferences, <span class="str">'$.theme'</span>) <span class="kwd">as</span> theme,
       <span class="func">JSON_EXTRACT</span>(preferences, <span class="str">'$.language'</span>) <span class="kwd">as</span> <span class="kwd">language</span>
<span class="kwd">FROM</span> users
<span class="kwd">WHERE</span> <span class="func">JSON_EXTRACT</span>(preferences, <span class="str">'$.newsletter'</span>) = true;

<span class="com">-- 向量相似性搜索（用于 <span class="kwd">AI</span> 应用）</span>
<span class="kwd">SELECT</span> username,
       <span class="func">VECTOR_DISTANCE</span>(user_embedding,
                       <span class="str">'[<span class="num">0</span>.<span class="num">1</span>, <span class="num">0</span>.<span class="num">2</span>, <span class="num">0</span>.<span class="num">3</span>, ..., <span class="num">0</span>.<span class="num">768</span>]'</span>) <span class="kwd">as</span> distance
<span class="kwd">FROM</span> users
<span class="kwd">ORDER BY</span> distance
<span class="kwd">LIMIT</span> <span class="num">10</span>;

<span class="com">-- 全文搜索（改进的全文索引）</span>
<span class="kwd">SELECT</span> username,
       <span class="func">MATCH</span>(username, email) <span class="func">AGAINST</span>(<span class="str">'zhangsan'</span> <span class="kwd">IN</span> <span class="kwd">NATURAL</span> <span class="kwd">LANGUAGE</span> MODE) <span class="kwd">as</span> relevance
<span class="kwd">FROM</span> users
<span class="kwd">WHERE</span> <span class="func">MATCH</span>(username, email) <span class="func">AGAINST</span>(<span class="str">'zhangsan'</span> <span class="kwd">IN</span> <span class="kwd">NATURAL</span> <span class="kwd">LANGUAGE</span> MODE);

<span class="com">-- 使用 <span class="kwd">AI</span> 优化提示</span>
<span class="kwd">SELECT</span> /*+ AI_OPTIMIZE */ * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span> <span class="kwd">ORDER BY</span> created_at DESC;

<span class="com">-- 分页查询（优化性能）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users
<span class="kwd">WHERE</span> id > <span class="num">1000</span>
<span class="kwd">ORDER BY</span> id
<span class="kwd">LIMIT</span> <span class="num">10</span>;

<span class="com">-- 窗口函数（分析查询）</span>
<span class="kwd">SELECT</span> username,
       age,
       <span class="func">RANK</span>() OVER (<span class="kwd">ORDER BY</span> age <span class="kwd">DESC</span>) <span class="kwd">as</span> age_rank,
       <span class="func">DENSE_RANK</span>() OVER (<span class="kwd">ORDER BY</span> age <span class="kwd">DESC</span>) <span class="kwd">as</span> dense_age_rank
<span class="kwd">FROM</span> users;</code></pre>
                </div>

                <h3>6. 更新数据</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 更新单条数据</span>
<span class="kwd">UPDATE</span> users <span class="kwd">SET</span> age = <span class="num">26</span> <span class="kwd">WHERE</span> username = <span class="str">'zhangsan'</span>;

<span class="com">-- 更新多条数据</span>
<span class="kwd">UPDATE</span> users <span class="kwd">SET</span> age = age + <span class="num">1</span> <span class="kwd">WHERE</span> age < <span class="num">30</span>;</code></pre>
                </div>

                <h3>7. 删除数据</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 删除单条数据</span>
<span class="kwd">DELETE</span> <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> id = <span class="num">1</span>;

<span class="com">-- 删除多条数据</span>
<span class="kwd">DELETE</span> <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age < <span class="num">25</span>;

<span class="com">-- 清空表</span>
TRUNCATE <span class="kwd">TABLE</span> users;</code></pre>
                </div>

                <h3 id="datatypes">8. 数据类型</h3>
                <p>MySQL 提供了丰富的数据类型，了解各种数据类型的特性对于设计高效的数据库表结构至关重要。</p>

                <h4>8.1 数值类型</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 整数类型</span>
TINYINT:       <span class="num">-128</span> 到 <span class="num">127</span> (或 <span class="num">0</span> 到 <span class="num">255</span> 无符号)
SMALLINT:      <span class="num">-32768</span> 到 <span class="num">32767</span>
MEDIUMINT:     <span class="num">-8388608</span> 到 <span class="num">8388607</span>
INT:           <span class="num">-2147483648</span> 到 <span class="num">2147483647</span> (常用)
BIGINT:        <span class="num">-9</span>.<span class="num">22</span>×10^<span class="num">18</span> 到 <span class="num">9</span>.<span class="num">22</span>×10^<span class="num">18</span>

<span class="com">-- 浮点数类型</span>
FLOAT(p):      单精度浮点数, p 表示精度
DOUBLE:        双精度浮点数
DECIMAL(m,d):  精确数值, m 是总位数, d 是小数位数 (用于金融计算)

<span class="com">-- 定点数示例</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> accounts (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    balance <span class="type">DECIMAL</span>(<span class="num">15</span>,<span class="num">2</span>) <span class="kwd">DEFAULT</span> <span class="num">0.00</span>,  <span class="com">-- 最多15位数字,2位小数</span>
    rate <span class="type">DECIMAL</span>(<span class="num">5</span>,<span class="num">4</span>) <span class="kwd">DEFAULT</span> <span class="num">0.0000</span>
);

<span class="com">-- BIT 类型 (位字段)</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> flags (
    flags <span class="type">BIT</span>(<span class="num">8</span>)  <span class="com">-- 存储8位二进制值</span>
);
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> flags <span class="kwd">VALUES</span>(<span class="num">b</span><span class="str">'10101010'</span>);</code></pre>
                </div>

                <h4>8.2 字符串类型</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 定长字符串</span>
CHAR(n):       固定长度, 最多 <span class="num">255</span> 字符, 不足部分用空格填充
CHAR(<span class="num">10</span>):      <span class="str">'hello'</span> 存储为 <span class="str">'hello     '</span>

<span class="com">-- 变长字符串</span>
VARCHAR(n):    可变长度, 最多 <span class="num">65535</span> 字节 (使用utf8mb4时最多 <span class="num">16383</span> 字符)
TINYTEXT:      最多 <span class="num">255</span> 字节
TEXT:          最多 <span class="num">65535</span> 字节
MEDIUMTEXT:    最多 <span class="num">16</span>MB
LONGTEXT:      最多 <span class="num">4</span>GB

<span class="com">-- 字符串示例</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> posts (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    title <span class="type">VARCHAR</span>(<span class="num">200</span>) <span class="kwd">NOT NULL</span>,
    summary <span class="type">TINYTEXT</span>,
    content <span class="type">TEXT</span>,
    bio <span class="type">MEDIUMTEXT</span>
);

<span class="com">-- ENUM 类型 (枚举)</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> orders (
    status <span class="type">ENUM</span>(<span class="str">'pending'</span>, <span class="str">'processing'</span>, <span class="str">'shipped'</span>, <span class="str">'delivered'</span>, <span class="str">'cancelled'</span>)
);
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> orders (status) <span class="kwd">VALUES</span>(<span class="str">'pending'</span>);

<span class="com">-- SET 类型 (集合)</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> user_profile (
    hobbies <span class="type">SET</span>(<span class="str">'reading'</span>, <span class="str">'sports'</span>, <span class="str">'music'</span>, <span class="str">'travel'</span>)
);
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> user_profile (hobbies) <span class="kwd">VALUES</span>(<span class="str">'reading,sports'</span>);</code></pre>
                </div>

                <h4>8.3 日期和时间类型</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 日期时间类型</span>
DATE:          日期, 格式: <span class="str">'YYYY-MM-DD'</span>, 范围: <span class="str">'1000-01-01'</span> 到 <span class="str">'9999-12-31'</span>
TIME:          时间, 格式: <span class="str">'HH:MM:SS'</span>, 范围: <span class="str">'-838:59:59'</span> 到 <span class="str">'838:59:59'</span>
DATETIME:      日期时间, 格式: <span class="str">'YYYY-MM-DD HH:MM:SS'</span>, 范围: <span class="str">'1000-01-01 00:00:00'</span>
TIMESTAMP:     时间戳, 范围: <span class="str">'1970-01-01 00:00:01'</span> 到 <span class="str">'2038-01-19 03:14:07'</span> (UTC)
YEAR:          年份, 格式: <span class="str">'YYYY'</span>

<span class="com">-- 日期时间示例</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> events (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    event_date <span class="type">DATE</span>,
    event_time <span class="type">TIME</span>,
    created_at <span class="type">DATETIME</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>,
    updated_at <span class="type">DATETIME</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span> <span class="kwd">ON</span> <span class="kwd">UPDATE</span> <span class="kwd">CURRENT_TIMESTAMP</span>,
    logged_at <span class="type">TIMESTAMP</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>
);

<span class="com">-- 插入日期时间值</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> events (event_date, event_time, created_at)
<span class="kwd">VALUES</span>(<span class="str">'2024-01-15'</span>, <span class="str">'14:30:00'</span>, <span class="str">'2024-01-15 14:30:00'</span>);

<span class="com">-- 使用 NOW() 获取当前时间</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> events (event_date, event_time)
<span class="kwd">VALUES</span>(<span class="func">CURDATE</span>(), <span class="func">CURTIME</span>());

<span class="com">-- TIMESTAMP 自动更新示例</span>
<span class="kwd">UPDATE</span> events <span class="kwd">SET</span> event_date = <span class="func">CURDATE</span>() <span class="kwd">WHERE</span> id = <span class="num">1</span>;</code></pre>
                </div>

                <h4>8.4 JSON 类型 (MySQL 5.7+)</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- JSON 类型用于存储结构化数据</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> user_preferences (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    user_id <span class="kwd">INT</span> <span class="kwd">NOT NULL</span>,
    preferences <span class="type">JSON</span>,
    settings <span class="type">JSON</span>
);

<span class="com">-- 插入 JSON 数据</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> user_preferences (user_id, preferences, settings)
<span class="kwd">VALUES</span>(
    <span class="num">1</span>,
    <span class="str">'{"theme": "dark", "language": "zh-CN", "notifications": true}'</span>,
    <span class="str">'{"privacy": "public", "two_factor": false}'</span>
);

<span class="com">-- 使用 JSON_EXTRACT 提取值</span>
<span class="kwd">SELECT</span>
    user_id,
    <span class="func">JSON_EXTRACT</span>(preferences, <span class="str">'$.theme'</span>) <span class="kwd">as</span> theme,
    <span class="func">JSON_EXTRACT</span>(preferences, <span class="str">'$.language'</span>) <span class="kwd">as</span> <span class="kwd">language</span>,
    <span class="func">JSON_EXTRACT</span>(preferences, <span class="str">'$.notifications'</span>) <span class="kwd">as</span> notifications
<span class="kwd">FROM</span> user_preferences;

<span class="com">-- 使用 JSON_SET 更新/添加值</span>
<span class="kwd">UPDATE</span> user_preferences
<span class="kwd">SET</span> preferences = <span class="func">JSON_SET</span>(preferences, <span class="str">'$.theme'</span>, <span class="str">'light'</span>, <span class="str">'$.font_size'</span>, <span class="str">'14px'</span>)
<span class="kwd">WHERE</span> user_id = <span class="num">1</span>;

<span class="com">-- 使用 JSON_REMOVE 删除值</span>
<span class="kwd">UPDATE</span> user_preferences
<span class="kwd">SET</span> preferences = <span class="func">JSON_REMOVE</span>(preferences, <span class="str">'$.notifications'</span>)
<span class="kwd">WHERE</span> user_id = <span class="num">1</span>;

<span class="com">-- 使用 JSON_KEYS 获取所有键</span>
<span class="kwd">SELECT</span> <span class="func">JSON_KEYS</span>(preferences) <span class="kwd">as</span> keys <span class="kwd">FROM</span> user_preferences;

<span class="com">-- JSON 数组操作</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> user_preferences (user_id, preferences)
<span class="kwd">VALUES</span>(<span class="num">2</span>, <span class="str">'{"tags": ["mysql", "database", "sql"]}'</span>);

<span class="kwd">SELECT</span> <span class="func">JSON_EXTRACT</span>(preferences, <span class="str">'$.tags[0]'</span>) <span class="kwd">as</span> first_tag <span class="kwd">FROM</span> user_preferences;</code></pre>
                </div>

                <h4>8.5 空间数据类型 (GIS)</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 空间数据类型</span>
GEOMETRY:      任意几何类型
POINT:         点 (x, y)
LINESTRING:    曲线 (点序列)
POLYGON:       多边形 (边界点序列)
MULTIPOINT:    点集合
MULTILINESTRING: 曲线集合
MULTIPOLYGON:  多边形集合
GEOMETRYCOLLECTION: 几何集合

<span class="com">-- 创建空间数据表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> locations (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    name <span class="type">VARCHAR</span>(<span class="num">100</span>),
    location POINT <span class="kwd">NOT NULL</span>,
    area POLYGON,
    route LINESTRING,
    <span class="kwd">SPATIAL</span> <span class="kwd">INDEX</span> idx_location (location)
);

<span class="com">-- 插入空间数据</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> locations (name, location)
<span class="kwd">VALUES</span>(
    <span class="str">'天安门广场'</span>,
    <span class="func">ST_GeomFromText</span>(<span class="str">'POINT(116.397428 39.90923)'</span>)
);

<span class="com">-- 查询坐标</span>
<span class="kwd">SELECT</span> name, <span class="func">ST_X</span>(location) <span class="kwd">as</span> longitude, <span class="func">ST_Y</span>(location) <span class="kwd">as</span> latitude
<span class="kwd">FROM</span> locations;

<span class="com">-- 计算两点距离 (米)</span>
<span class="kwd">SELECT</span> <span class="func">ST_Distance_Sphere</span>(
    <span class="func">ST_GeomFromText</span>(<span class="str">'POINT(116.397428 39.90923)'</span>),
    <span class="func">ST_GeomFromText</span>(<span class="str">'POINT(121.473701 31.230416)'</span>)
) <span class="kwd">as</span> distance_meters;

<span class="com">-- 创建多边形</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> locations (name, area)
<span class="kwd">VALUES</span>(
    <span class="str">'北京市'</span>,
    <span class="func">ST_GeomFromText</span>(<span class="str">'POLYGON((116.0 39.0, 117.0 39.0, 117.0 41.0, 116.0 41.0, 116.0 39.0))'</span>)
);

<span class="com">-- 判断点是否在多边形内</span>
<span class="kwd">SELECT</span> name <span class="kwd">FROM</span> locations
<span class="kwd">WHERE</span> <span class="func">ST_Contains</span>(
    area,
    <span class="func">ST_GeomFromText</span>(<span class="str">'POINT(116.5 40.0)'</span>)
);</code></pre>
                </div>

                <h4>8.6 向量类型 (MySQL 9.0+ AI 增强)</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 向量类型用于存储嵌入向量 (AI/ML 应用)</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> document_embeddings (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    doc_id <span class="kwd">INT</span> <span class="kwd">NOT NULL</span>,
    embedding VECTOR(<span class="num">768</span>),  <span class="com">-- 768维向量 (BERT等模型常用)</span>
    <span class="kwd">INDEX</span> idx_embedding (embedding)
);

<span class="com">-- 插入向量数据 (需要转换为字符串格式)</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> document_embeddings (doc_id, embedding)
<span class="kwd">VALUES</span>(
    <span class="num">1</span>,
    <span class="str">'[0.1, 0.2, 0.3, 0.0, -0.1, 0.5, -0.3, 0.8, ...]'</span>
);

<span class="com">-- 向量相似性搜索 (余弦相似度)</span>
<span class="kwd">SELECT</span>
    doc_id,
    <span class="func">VECTOR_DISTANCE</span>(embedding, <span class="str">'[0.1, 0.2, 0.3, 0.0, -0.1, 0.5, -0.3, 0.8, ...]'</span>, <span class="str">'cosine'</span>) <span class="kwd">as</span> similarity
<span class="kwd">FROM</span> document_embeddings
<span class="kwd">ORDER BY</span> similarity
<span class="kwd">LIMIT</span> <span class="num">5</span>;

<span class="com">-- 欧氏距离</span>
<span class="kwd">SELECT</span>
    doc_id,
    <span class="func">VECTOR_DISTANCE</span>(embedding, <span class="str">'[0.1, 0.2, 0.3, ...]'</span>, <span class="str">'euclidean'</span>) <span class="kwd">as</span> distance
<span class="kwd">FROM</span> document_embeddings
<span class="kwd">ORDER BY</span> distance
<span class="kwd">LIMIT</span> <span class="num">5</span>;

<span class="com">-- 内积</span>
<span class="kwd">SELECT</span>
    doc_id,
    <span class="func">VECTOR_DISTANCE</span>(embedding, <span class="str">'[0.1, 0.2, 0.3, ...]'</span>, <span class="str">'dot_product'</span>) <span class="kwd">as</span> score
<span class="kwd">FROM</span> document_embeddings
<span class="kwd">ORDER BY</span> score DESC
<span class="kwd">LIMIT</span> <span class="num">5</span>;

<span class="com">-- 使用 HNSW 索引加速向量搜索</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> document_embeddings
ADD <span class="kwd">INDEX</span> idx_hnsw (embedding) <span class="kwd">INDEX_TYPE</span> = <span class="str">'HNSW'</span> <span class="kwd">PARAMETERS</span> = <span class="str">'{"m": 16, "ef_construction": 200}'</span>;</code></pre>
                </div>

                <h4>8.7 数据类型选择建议</h4>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>数据类型</th>
                                <th>存储空间</th>
                                <th>取值范围</th>
                                <th>适用场景</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>TINYINT</td>
                                <td>1 字节</td>
                                <td>-128 ~ 127</td>
                                <td>布尔值、状态码、年龄</td>
                            </tr>
                            <tr>
                                <td>SMALLINT</td>
                                <td>2 字节</td>
                                <td>-32768 ~ 32767</td>
                                <td>数量、计数器</td>
                            </tr>
                            <tr>
                                <td>INT</td>
                                <td>4 字节</td>
                                <td>-21亿 ~ 21亿</td>
                                <td>通用整数、主键</td>
                            </tr>
                            <tr>
                                <td>BIGINT</td>
                                <td>8 字节</td>
                                <td>-9.2×10¹⁸ ~ 9.2×10¹⁸</td>
                                <td>大数值、精确计数</td>
                            </tr>
                            <tr>
                                <td>VARCHAR(n)</td>
                                <td>变长 + 1-2字节</td>
                                <td>最大 65535 字节</td>
                                <td>可变长度字符串</td>
                            </tr>
                            <tr>
                                <td>TEXT</td>
                                <td>4 字节 + 数据</td>
                                <td>最大 64KB</td>
                                <td>长文本文章</td>
                            </tr>
                            <tr>
                                <td>DECIMAL(m,d)</td>
                                <td>变长</td>
                                <td>精确数值</td>
                                <td>金融计算</td>
                            </tr>
                            <tr>
                                <td>DATETIME</td>
                                <td>8 字节</td>
                                <td>1000-01-01 ~ 9999-12-31</td>
                                <td>需要大范围时间</td>
                            </tr>
                            <tr>
                                <td>TIMESTAMP</td>
                                <td>4 字节</td>
                                <td>1970-2038</td>
                                <td>自动记录时间</td>
                            </tr>
                            <tr>
                                <td>JSON</td>
                                <td>变长</td>
                                <td>灵活结构化数据</td>
                                <td>配置、用户偏好</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 数据类型选择原则</span>

<span class="com">-- 1. 选择最小的数据类型</span>
<span class="com">-- 不推荐: INT UNSIGNED 对于 0-100 的值</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> age_table (
    age TINYINT UNSIGNED  <span class="com">-- 0-255, 比 INT 节省3字节</span>
);

<span class="com">-- 2. 使用 VARCHAR(n) 而非 CHAR(n) 当字符串长度不确定时</span>
<span class="com">-- CHAR(10) 始终占用10字节, VARCHAR(10) 按实际长度</span>

<span class="com">-- 3. 使用 DECIMAL 而非 FLOAT/DOUBLE 用于精确数值</span>
<span class="com">-- 金融计算: DECIMAL(15,2) vs FLOAT</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> accounts (
    balance <span class="type">DECIMAL</span>(<span class="num">15</span>,<span class="num">2</span>)  <span class="com">-- 精确</span>
);

<span class="com">-- 4. 使用 TIMESTAMP 而非 DATETIME 当需要自动更新时</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> logs (
    created_at TIMESTAMP <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>,  <span class="com">-- 自动设置</span>
    updated_at TIMESTAMP <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span> <span class="kwd">ON</span> <span class="kwd">UPDATE</span> <span class="kwd">CURRENT_TIMESTAMP</span>  <span class="com">-- 自动更新</span>
);

<span class="com">-- 5. 使用 JSON 类型存储灵活的结构化数据</span>
<span class="com">-- 但不要滥用, 频繁查询的字段应该用独立列</span>

<span class="com">-- 6. 考虑字符集: 使用 utf8mb4 支持emoji</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> messages (
    content <span class="type">VARCHAR</span>(<span class="num">1000</span>) <span class="kwd">CHARSET</span> utf8mb4 COLLATE utf8mb4_unicode_ci
);

<span class="com">-- 7. 有符号 vs 无符号</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> counters (
    positive_count TINYINT UNSIGNED,  <span class="com">-- 0-255</span>
    signed_count TINYINT               <span class="com">-- -128 到 127</span>
);</code></pre>
                </div>
            </div>
        </section>
            <h2>高级特性</h2>
            <div class="content">
                <h3>1. 索引详解（AI 驱动）</h3>

                <h4>1.1 什么是索引？</h4>
                <p>索引是数据库中用于加速数据检索的数据结构。就像书籍的目录一样，索引可以帮助快速定位数据，而不需要扫描整个表。合理的索引设计可以显著提升查询性能，但也会占用存储空间并影响写入性能。</p>

                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 查看表的当前索引状态</span>
<span class="kwd">SHOW</span> <span class="kwd">INDEX</span> <span class="kwd">FROM</span> users;

<span class="com">-- 分析表获取索引使用统计</span>
<span class="kwd">ANALYZE</span> <span class="kwd">TABLE</span> users;

<span class="com">-- 查看索引统计信息</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> mysql.innodb_index_stats
<span class="kwd">WHERE</span> database_name = <span class="kwd">DATABASE</span>() <span class="kwd">AND</span> table_name = <span class="str">'users'</span>;</code></pre>
                </div>

                <details>
                    <summary>1.2 索引类型（点击展开）</summary>

                <h5>1.2.1 主键索引（PRIMARY KEY）</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 主键索引（自动创建，唯一且非空）</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> users (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    username <span class="type">VARCHAR</span>(<span class="num">100</span>)
);

<span class="com">-- 或者单独定义</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> users (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span>,
    username <span class="type">VARCHAR</span>(<span class="num">100</span>),
    <span class="kwd">PRIMARY KEY</span> (id)
);

<span class="com">-- 复合主键</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> user_scores (
    user_id <span class="type">INT</span>,
    game_id <span class="type">INT</span>,
    score <span class="type">INT</span>,
    <span class="kwd">PRIMARY KEY</span> (user_id, game_id)
);</code></pre>
                </div>

                <h5>1.2.2 唯一索引（UNIQUE）</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 创建唯一索引（确保列值唯一）</span>
<span class="kwd">CREATE</span> <span class="kwd">UNIQUE</span> <span class="kwd">INDEX</span> idx_email <span class="kwd">ON</span> users(email);

<span class="com">-- 在表定义中创建</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> users (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    username <span class="type">VARCHAR</span>(<span class="num">100</span>),
    email <span class="type">VARCHAR</span>(<span class="num">255</span>) <span class="kwd">UNIQUE</span>
);

<span class="com">-- 复合唯一索引</span>
<span class="kwd">CREATE</span> <span class="kwd">UNIQUE</span> <span class="kwd">INDEX</span> idx_username_email <span class="kwd">ON</span> users(username, email);</code></pre>
                </div>

                <h5>1.2.3 普通索引（INDEX）</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 创建普通索引</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_username <span class="kwd">ON</span> users(username);

<span class="com">-- 复合索引（最左前缀原则）</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_age_email <span class="kwd">ON</span> users(age, email);

<span class="com">-- 使用复合索引的查询会命中索引</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age = <span class="num">25</span>; <span class="com">-- 命中</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age = <span class="num">25</span> <span class="kwd">AND</span> email = <span class="str">'test@example.com'</span>; <span class="com">-- 命中</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> email = <span class="str">'test@example.com'</span>; <span class="com">-- 不命中</span>

<span class="com">-- 添加索引</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users ADD <span class="kwd">INDEX</span> idx_created_at (created_at);</code></pre>
                </div>

                <h5>1.2.4 全文索引（FULLTEXT）</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 全文索引（用于文本搜索）</span>
<span class="kwd">CREATE</span> <span class="kwd">FULLTEXT</span> <span class="kwd">INDEX</span> idx_content <span class="kwd">ON</span> articles(content);

<span class="com">-- 全文搜索</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> articles
<span class="kwd">WHERE</span> <span class="func">MATCH</span>(content) <span class="func">AGAINST</span>(<span class="str">'MySQL 教程'</span> <span class="kwd">IN</span> <span class="kwd">NATURAL</span> <span class="kwd">LANGUAGE</span> MODE);

<span class="com">-- 布尔模式搜索</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> articles
<span class="kwd">WHERE</span> <span class="func">MATCH</span>(content, title) <span class="func">AGAINST</span>(<span class="str">'MySQL +教程 -基础'</span> <span class="kwd">IN</span> BOOLEAN MODE);

<span class="com">-- 查询扩展模式</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> articles
<span class="kwd">WHERE</span> <span class="func">MATCH</span>(content) <span class="func">AGAINST</span>(<span class="str">'MySQL'</span> <span class="kwd">WITH</span> <span class="kwd">QUERY</span> EXPANSION);

<span class="com">-- 中文分词支持</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> articles (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    content <span class="type">TEXT</span>,
    <span class="kwd">FULLTEXT</span> <span class="kwd">INDEX</span> ft_content (content) <span class="kwd">WITH</span> PARSER ngram
);</code></pre>
                </div>

                <h5>1.2.5 空间索引（SPATIAL）</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 空间索引（用于地理数据）</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> locations (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    name <span class="type">VARCHAR</span>(<span class="num">100</span>),
    location GEOMETRY <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    <span class="kwd">SPATIAL</span> <span class="kwd">INDEX</span> idx_location (location)
);

<span class="com">-- 插入空间数据</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> locations (name, location) <span class="kwd">VALUES</span>
(<span class="str">'Beijing'</span>, <span class="func">ST_GeomFromText</span>(<span class="str">'<span class="type">POINT</span>(<span class="num">116</span>.<span class="num">4074</span> <span class="num">39</span>.<span class="num">9042</span>)'</span>)),
(<span class="str">'Shanghai'</span>, <span class="func">ST_GeomFromText</span>(<span class="str">'<span class="type">POINT</span>(<span class="num">121</span>.<span class="num">4737</span> <span class="num">31</span>.<span class="num">2304</span>)'</span>));

<span class="com">-- 空间查询</span>
<span class="kwd">SELECT</span> name, <span class="func">ST_AsText</span>(location) <span class="kwd">as</span> coordinates
<span class="kwd">FROM</span> locations
<span class="kwd">WHERE</span> <span class="func">ST_Distance_Sphere</span>(
    location,
    <span class="func">ST_GeomFromText</span>(<span class="str">'<span class="type">POINT</span>(<span class="num">116</span>.<span class="num">4074</span> <span class="num">39</span>.<span class="num">9042</span>)'</span>)
) < <span class="num">50000</span>; <span class="com">-- 50公里范围内</span></code></pre>
                </div>

                <h5>1.2.6 前缀索引</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 前缀索引（节省空间，适用于长字符串）</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_email_prefix <span class="kwd">ON</span> users(email(<span class="num">20</span>));

<span class="com">-- 查看前缀长度建议</span>
<span class="kwd">SELECT</span>
    <span class="func">COUNT</span>(<span class="kwd">DISTINCT</span> LEFT(email, <span class="num">10</span>)) <span class="kwd">as</span> distinct_10,
    <span class="func">COUNT</span>(<span class="kwd">DISTINCT</span> LEFT(email, <span class="num">20</span>)) <span class="kwd">as</span> distinct_20,
    <span class="func">COUNT</span>(<span class="kwd">DISTINCT</span> LEFT(email, <span class="num">30</span>)) <span class="kwd">as</span> distinct_30
<span class="kwd">FROM</span> users;

<span class="com">-- 创建合适长度的前缀索引</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_title_prefix <span class="kwd">ON</span> articles(title(<span class="num">50</span>));</code></pre>
                </div>

                <h5>1.2.7 函数索引</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 函数索引（对表达式建立索引）</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_email_lower <span class="kwd">ON</span> users((<span class="func">LOWER</span>(email)));

<span class="com">-- 使用函数索引的查询</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> <span class="func">LOWER</span>(email) = <span class="str">'test@example.com'</span>;

<span class="com">-- 计算列索引</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> products ADD COLUMN discounted_price <span class="type">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>);
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_discounted_price <span class="kwd">ON</span> products((price * discount_rate));

<span class="com">-- <span class="kwd">JSON</span> 列索引</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_user_prefs <span class="kwd">ON</span> users((<span class="func">JSON_EXTRACT</span>(preferences, <span class="str">'$.language'</span>)));
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users
<span class="kwd">WHERE</span> <span class="func">JSON_EXTRACT</span>(preferences, <span class="str">'$.language'</span>) = <span class="str">'zh-CN'</span>;
                </div>
                </details>

                <h4>1.3 索引设计原则</h4>

                <h5>1.3.1 选择合适的列建立索引</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 建议索引的列类型：</span>
<span class="com">-- <span class="num">1</span>. 经常在 <span class="kwd">WHERE</span> 条件中使用的列</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_status <span class="kwd">ON</span> orders(<span class="kwd">status</span>);

<span class="com">-- <span class="num">2</span>. 经常在 JOIN 条件中使用的列</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_user_id <span class="kwd">ON</span> orders(user_id);

<span class="com">-- <span class="num">3</span>. 经常在 <span class="kwd">ORDER BY</span> 中使用的列</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_created_at <span class="kwd">ON</span> posts(created_at);

<span class="com">-- <span class="num">4</span>. 经常在 <span class="kwd">GROUP BY</span> 中使用的列</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_category <span class="kwd">ON</span> posts(category_id);

<span class="com">-- <span class="num">5</span>. 唯一性高的列</span>
<span class="kwd">CREATE</span> <span class="kwd">UNIQUE</span> <span class="kwd">INDEX</span> idx_username <span class="kwd">ON</span> users(username);</code></pre>
                </div>

                <h5>1.3.2 复合索引的列顺序</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 复合索引设计原则：</span>
<span class="com">-- <span class="num">1</span>. 将选择性高的列放在前面</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_status_created <span class="kwd">ON</span> orders(<span class="kwd">status</span>, created_at);

<span class="com">-- <span class="num">2</span>. 考虑查询的列顺序</span>
<span class="com">-- 常见查询：<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> user_id = ? <span class="kwd">AND</span> <span class="kwd">status</span> = ?</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_user_status <span class="kwd">ON</span> orders(user_id, <span class="kwd">status</span>);

<span class="com">-- <span class="num">3</span>. 最左前缀原则</span>
<span class="com">-- 索引 (user_id, <span class="kwd">status</span>, created_at)</span>
<span class="com">-- 可以使用索引的查询：</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> user_id = <span class="num">1</span>;
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> user_id = <span class="num">1</span> <span class="kwd">AND</span> <span class="kwd">status</span> = <span class="str">'pending'</span>;
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> user_id = <span class="num">1</span> <span class="kwd">AND</span> <span class="kwd">status</span> = <span class="str">'pending'</span> <span class="kwd">AND</span> created_at > <span class="str">'<span class="num">2024</span>-<span class="num">01</span>-<span class="num">01</span>'</span>;

<span class="com">-- 不可以使用索引的查询：</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> <span class="kwd">status</span> = <span class="str">'pending'</span>; <span class="com">-- 跳过最左列</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> created_at > <span class="str">'<span class="num">2024</span>-<span class="num">01</span>-<span class="num">01</span>'</span>; <span class="com">-- 跳过前两列</span></code></pre>
                </div>

                <h5>1.3.3 覆盖索引</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 覆盖索引（索引包含查询所需的所有列）</span>
<span class="com">-- 索引包含：user_id, <span class="kwd">status</span>, total_amount</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_user_status_amount <span class="kwd">ON</span> orders(user_id, <span class="kwd">status</span>, total_amount);

<span class="com">-- 查询只使用索引，不需要回表</span>
<span class="kwd">SELECT</span> user_id, <span class="kwd">status</span>, total_amount
<span class="kwd">FROM</span> orders
<span class="kwd">WHERE</span> user_id = <span class="num">1</span> <span class="kwd">AND</span> <span class="kwd">status</span> = <span class="str">'completed'</span>;

<span class="com">-- 使用 <span class="kwd">EXPLAIN</span> 验证是否使用覆盖索引</span>
<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> user_id, <span class="kwd">status</span>, total_amount
<span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> user_id = <span class="num">1</span> <span class="kwd">AND</span> <span class="kwd">status</span> = <span class="str">'completed'</span>;

<span class="com">-- Extra 字段显示 "Using index" 表示使用了覆盖索引</span></code></pre>
                </div>

                <h4>1.4 索引管理</h4>

                <h5>1.4.1 查看索引信息</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 查看表的所有索引</span>
<span class="kwd">SHOW</span> <span class="kwd">INDEX</span> <span class="kwd">FROM</span> users;

<span class="com">-- 查看索引的统计信息</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> mysql.innodb_index_stats
<span class="kwd">WHERE</span> database_name = <span class="kwd">DATABASE</span>() <span class="kwd">AND</span> table_name = <span class="str">'users'</span>;

<span class="com">-- 查看索引使用情况</span>
<span class="kwd">SELECT</span>
    table_name,
    index_name,
    cardinality,
    nullable,
    index_type
<span class="kwd">FROM</span> information_schema.statistics
<span class="kwd">WHERE</span> table_schema = <span class="kwd">DATABASE</span>()
<span class="kwd">ORDER BY</span> table_name, index_name;

<span class="com">-- 查看未使用的索引</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.schema_unused_indexes
<span class="kwd">WHERE</span> object_schema = <span class="kwd">DATABASE</span>();</code></pre>
                </div>

                <h5>1.4.2 索引维护</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 分析表（更新索引统计信息）</span>
<span class="kwd">ANALYZE</span> <span class="kwd">TABLE</span> users;

<span class="com">-- 优化表（重建表和索引）</span>
<span class="kwd">OPTIMIZE</span> <span class="kwd">TABLE</span> users;

<span class="com">-- 重建索引</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users ENGINE=InnoDB;

<span class="com">-- 清理碎片</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users ENGINE=InnoDB;

<span class="com">-- 禁用索引（批量导入时提升性能）</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users <span class="kwd">DISABLE</span> KEYS;
<span class="com">-- 批量插入数据</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users <span class="kwd">ENABLE</span> KEYS;</code></pre>
                </div>

                <h5>1.4.3 索引删除</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 删除索引</span>
<span class="kwd">DROP</span> <span class="kwd">INDEX</span> idx_username <span class="kwd">ON</span> users;

<span class="com">-- 删除主键（如果有自增列需要先删除）</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users <span class="kwd">DROP</span> PRIMARY KEY;

<span class="com">-- 删除多个索引</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users
    <span class="kwd">DROP</span> <span class="kwd">INDEX</span> idx_email,
    <span class="kwd">DROP</span> <span class="kwd">INDEX</span> idx_age;</code></pre>
                </div>

                <h4>1.5 AI 智能索引优化</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- <span class="kwd">AI</span> 自动索引推荐</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.ai_index_recommendations
<span class="kwd">WHERE</span> table_name = <span class="str">'users'</span>
<span class="kwd">ORDER BY</span> potential_improvement DESC;

<span class="com">-- 应用 <span class="kwd">AI</span> 推荐的索引</span>
<span class="kwd">CALL</span> sys.apply_ai_index_recommendations(<span class="str">'users'</span>);

<span class="com">-- 查看 <span class="kwd">AI</span> 优化建议详情</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.ai_query_analysis
<span class="kwd">WHERE</span> query_time > <span class="func">NOW</span>() - INTERVAL <span class="num">1</span> DAY;

<span class="com">-- <span class="kwd">AI</span> 实时监控索引效果</span>
<span class="kwd">SELECT</span>
    index_name,
    used_count,
    avg_access_time,
    improvement_percentage
<span class="kwd">FROM</span> sys.ai_index_performance_monitor
<span class="kwd">WHERE</span> table_name = <span class="str">'users'</span>;</code></pre>
                </div>

                <h4>1.6 索引性能优化技巧</h4>

                <h5>1.6.1 隐藏索引（测试性能）</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 创建隐藏索引（不实际使用，用于测试）</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_test <span class="kwd">ON</span> users(username) INVISIBLE;

<span class="com">-- 将已有索引设为隐藏</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users <span class="kwd">ALTER</span> <span class="kwd">INDEX</span> idx_username INVISIBLE;

<span class="com">-- 显示隐藏索引</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users <span class="kwd">ALTER</span> <span class="kwd">INDEX</span> idx_username VISIBLE;

<span class="com">-- 查看隐藏索引</span>
<span class="kwd">SELECT</span> index_name, is_visible
<span class="kwd">FROM</span> information_schema.statistics
<span class="kwd">WHERE</span> table_schema = <span class="kwd">DATABASE</span>() <span class="kwd">AND</span> table_name = <span class="str">'users'</span> <span class="kwd">AND</span> is_visible = <span class="str">'NO'</span>;</code></pre>
                </div>

                <h5>1.6.2 索引提示</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 强制使用指定索引</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">USE</span> <span class="kwd">INDEX</span> (idx_username) <span class="kwd">WHERE</span> username = <span class="str">'test'</span>;

<span class="com">-- 强制不使用索引（全表扫描）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users IGNORE <span class="kwd">INDEX</span> (idx_username) <span class="kwd">WHERE</span> username = <span class="str">'test'</span>;

<span class="com">-- 指定多个索引</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">USE</span> <span class="kwd">INDEX</span> (idx_username, idx_email)
<span class="kwd">WHERE</span> username = <span class="str">'test'</span> <span class="kwd">OR</span> email = <span class="str">'test@example.com'</span>;</code></pre>
                </div>

                <h5>1.6.3 索引下推优化</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- MySQL <span class="num">8</span>.<span class="num">0</span>+ 支持索引下推</span>
<span class="com">-- 对于复合索引，条件过滤在存储引擎层完成</span>
<span class="com">-- 示例：索引 (name, age)</span>
<span class="com">-- 查询：<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> name = <span class="str">'test'</span> <span class="kwd">AND</span> age > <span class="num">25</span></span>
<span class="com">-- MySQL 会先在索引中过滤 age > <span class="num">25</span>，减少回表次数</span>

<span class="com">-- 查看是否使用了索引下推</span>
<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users
<span class="kwd">WHERE</span> name = <span class="str">'test'</span> <span class="kwd">AND</span> age > <span class="num">25</span>;
<span class="com">-- Extra 字段显示 "Using <span class="kwd">index</span> condition" 表示使用了索引下推</span></code></pre>
                </div>

                <h4>1.7 索引最佳实践</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 最佳实践总结：</span>

<span class="com">-- <span class="num">1</span>. 为 WHERE、JOIN、ORDER BY、<span class="kwd">GROUP BY</span> 中的列创建索引</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_user_status <span class="kwd">ON</span> orders(user_id, <span class="kwd">status</span>);

<span class="com">-- <span class="num">2</span>. 避免在区分度低的列上创建索引（如性别、布尔值）</span>
<span class="com">-- 不推荐：<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_gender <span class="kwd">ON</span> users(gender);</span>

<span class="com">-- <span class="num">3</span>. 不要过度索引（索引会占用空间并降低写入性能）</span>
<span class="com">-- 定期检查未使用的索引并删除</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.schema_unused_indexes;

<span class="com">-- <span class="num">4</span>. 使用 <span class="kwd">EXPLAIN</span> 分析查询计划</span>
<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span>;

<span class="com">-- <span class="num">5</span>. 定期维护索引</span>
<span class="kwd">ANALYZE</span> <span class="kwd">TABLE</span> users; <span class="com">-- 更新统计信息</span>
<span class="kwd">OPTIMIZE</span> <span class="kwd">TABLE</span> users; <span class="com">-- 重建表和索引</span>

<span class="com">-- <span class="num">6</span>. 使用覆盖索引减少回表</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_covering <span class="kwd">ON</span> orders(user_id, <span class="kwd">status</span>, total_amount);

<span class="com">-- <span class="num">7</span>. 合理使用复合索引，遵循最左前缀原则</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_user_created <span class="kwd">ON</span> orders(user_id, created_at);

<span class="com">-- <span class="num">8</span>. 大表删除和更新时考虑索引影响</span>
<span class="com">-- 可以先禁用索引，操作完成后再启用</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> large_table <span class="kwd">DISABLE</span> KEYS;
<span class="com">-- 执行批量操作</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> large_table <span class="kwd">ENABLE</span> KEYS;

<span class="com">-- <span class="num">9</span>. 利用 <span class="kwd">AI</span> 智能推荐</span>
<span class="kwd">CALL</span> sys.recommend_indexes(<span class="str">'your_database'</span>);

<span class="com">-- <span class="num">10</span>. 监控索引性能，及时调整</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.schema_index_statistics
<span class="kwd">WHERE</span> table_schema = <span class="kwd">DATABASE</span>();</code></pre>
                </div>

                <h4>1.8 索引常见问题</h4>

                <h5>1.8.1 索引失效的场景</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 索引失效的常见场景：</span>

<span class="com">-- <span class="num">1</span>. 使用函数或表达式</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> <span class="func">LOWER</span>(username) = <span class="str">'test'</span>; <span class="com">-- username 索引失效</span>
<span class="com">-- 解决：创建函数索引</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_username_lower <span class="kwd">ON</span> users((<span class="func">LOWER</span>(username)));

<span class="com">-- <span class="num">2</span>. 类型不匹配</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> id = <span class="str">'<span class="num">1</span>'</span>; <span class="com">-- id 是数字类型，字符串导致索引失效</span>
<span class="com">-- 解决：保持类型一致</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> id = <span class="num">1</span>;

<span class="com">-- <span class="num">3</span>. <span class="kwd">LIKE</span> 查询以通配符开头</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> username <span class="kwd">LIKE</span> <span class="str">'%test%'</span>; <span class="com">-- 索引失效</span>
<span class="com">-- 解决：使用全文索引或避免前导通配符</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> username <span class="kwd">LIKE</span> <span class="str">'test%'</span>; <span class="com">-- 索引有效</span>

<span class="com">-- <span class="num">4</span>. <span class="kwd">OR</span> 条件</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> username = <span class="str">'test'</span> <span class="kwd">OR</span> email = <span class="str">'test@example.com'</span>;
<span class="com">-- 如果两个字段都有索引，会分别使用，但效率可能不如 UNION</span>
<span class="com">-- 解决：使用 <span class="kwd">UNION</span> ALL</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> username = <span class="str">'test'</span>
<span class="kwd">UNION</span> <span class="kwd">ALL</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> email = <span class="str">'test@example.com'</span>;

<span class="com">-- <span class="num">5</span>. <span class="kwd">NOT</span> <span class="kwd">IN</span>, <span class="kwd">NOT</span> <span class="kwd">EXISTS</span>, <></span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> username <> <span class="str">'test'</span>; <span class="com">-- 索引可能失效</span>

<span class="com">-- <span class="num">6</span>. 查询条件中包含 NULL</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> username <span class="kwd">IS</span> NULL; <span class="com">-- 如果 username 有索引，可以命中</span></code></pre>
                </div>

                <h5>1.8.2 索引碎片问题</h5>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 检测索引碎片</span>
<span class="kwd">SELECT</span>
    table_name,
    <span class="kwd">engine</span>,
    ROUND(data_length / <span class="num">1024</span> / <span class="num">1024</span>, <span class="num">2</span>) <span class="kwd">as</span> data_mb,
    ROUND(index_length / <span class="num">1024</span> / <span class="num">1024</span>, <span class="num">2</span>) <span class="kwd">as</span> index_mb,
    ROUND(data_free / <span class="num">1024</span> / <span class="num">1024</span>, <span class="num">2</span>) <span class="kwd">as</span> free_mb
<span class="kwd">FROM</span> information_schema.<span class="kwd">tables</span>
<span class="kwd">WHERE</span> table_schema = <span class="kwd">DATABASE</span>()
<span class="kwd">ORDER BY</span> data_free DESC;

<span class="com">-- 重建索引和表（消除碎片）</span>
<span class="kwd">OPTIMIZE</span> <span class="kwd">TABLE</span> users;

<span class="com">-- 或者重建表</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users ENGINE=InnoDB;

<span class="com">-- 对于大表，可以使用 pt-online-schema-change 在线重建</span>
<span class="com">-- pt-online-schema-change --<span class="kwd">alter</span> "ENGINE=InnoDB" D=your_database,t=users --execute</span></code></pre>
                </div>

                <h3>2. 事务处理（支持分布式事务）</h3>
                <p>事务是数据库管理系统执行过程中的一个逻辑单位，由一系列SQL语句组成。事务具有ACID特性：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。</p>
                
                <div class="mermaid">
flowchart TD
    A[开始事务] --> B{执行SQL语句}
    
    B --> C[写UNDO日志]
    C --> D[修改数据缓存]
    D --> E{操作成功?}
    
    E -->|是| F{提交还是回滚?}
    E -->|否| G[回滚事务]
    
    G --> H[读取UNDO日志]
    H --> I[恢复数据]
    I --> J[结束事务]
    
    F -->|COMMIT| K[写入COMMIT标记]
    K --> L[刷新REDO日志到磁盘]
    L --> M[释放锁]
    M --> J
    
    F -->|ROLLBACK| G
    
    style A fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style J fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style G fill:#ffcdd2,stroke:#c62828,stroke-width:2px
    style L fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
</div>
                
                <h4>ACID 特性说明：</h4>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>特性</th>
                                <th>描述</th>
                                <th>实现原理</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>原子性 (A)</strong></td>
                                <td>事务中的所有操作要么全部成功，要么全部失败</td>
                                <td>UNDO日志</td>
                            </tr>
                            <tr>
                                <td><strong>一致性 (C)</strong></td>
                                <td>事务执行前后，数据库状态保持一致</td>
                                <td>约束、触发器</td>
                            </tr>
                            <tr>
                                <td><strong>隔离性 (I)</strong></td>
                                <td>并发事务之间互不干扰</td>
                                <td>锁机制、MVCC</td>
                            </tr>
                            <tr>
                                <td><strong>持久性 (D)</strong></td>
                                <td>事务提交后，修改永久保存</td>
                                <td>REDO日志</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 开始事务</span>
START TRANSACTION;

<span class="com">-- 执行 SQL 语句</span>
<span class="kwd">UPDATE</span> accounts <span class="kwd">SET</span> balance = balance - <span class="num">100</span> <span class="kwd">WHERE</span> id = <span class="num">1</span>;
<span class="kwd">UPDATE</span> accounts <span class="kwd">SET</span> balance = balance + <span class="num">100</span> <span class="kwd">WHERE</span> id = <span class="num">2</span>;

<span class="com">-- 提交事务（自动使用 2PC）</span>
COMMIT;

<span class="com">-- 或回滚事务</span>
ROLLBACK;

<span class="com">-- 保存点</span>
SAVEPOINT sp1;
<span class="kwd">UPDATE</span> accounts <span class="kwd">SET</span> balance = balance - <span class="num">50</span> <span class="kwd">WHERE</span> id = <span class="num">1</span>;
<span class="com">-- 回滚到保存点</span>
<span class="kwd">ROLLBACK</span> TO sp1;

<span class="com">-- 分布式事务（XA 事务改进）</span>
XA START <span class="str">'xid1'</span>;
<span class="kwd">UPDATE</span> accounts <span class="kwd">SET</span> balance = balance - <span class="num">100</span> <span class="kwd">WHERE</span> id = <span class="num">1</span>;
XA <span class="kwd">END</span> <span class="str">'xid1'</span>;
XA PREPARE <span class="str">'xid1'</span>;
XA <span class="kwd">COMMIT</span> <span class="str">'xid1'</span>;</code></pre>
                </div>

                <h3>3. 视图（物化视图）</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 创建普通视图</span>
<span class="kwd">CREATE</span> <span class="kwd">VIEW</span> user_summary <span class="kwd">AS</span>
<span class="kwd">SELECT</span>
    username,
    email,
    <span class="func">TIMESTAMPDIFF</span>(<span class="type">YEAR</span>, created_at, <span class="func">NOW</span>()) <span class="kwd">as</span> years_active
<span class="kwd">FROM</span> users;

<span class="com">-- 创建物化视图（MySQL <span class="num">9</span>.x 新增）</span>
<span class="kwd">CREATE</span> <span class="kwd">MATERIALIZED</span> <span class="kwd">VIEW</span> mv_user_stats
<span class="kwd">REFRESH</span> <span class="kwd">EVERY</span> <span class="num">1</span> <span class="kwd">HOUR</span>
<span class="kwd">AS</span>
<span class="kwd">SELECT</span>
    <span class="func">COUNT</span>(*) <span class="kwd">as</span> total_users,
    <span class="func">AVG</span>(age) <span class="kwd">as</span> avg_age,
    <span class="func">MAX</span>(created_at) <span class="kwd">as</span> last_signup
<span class="kwd">FROM</span> users;

<span class="com">-- 手动刷新物化视图</span>
<span class="kwd">REFRESH</span> <span class="kwd">MATERIALIZED</span> <span class="kwd">VIEW</span> mv_user_stats;

<span class="com">-- 使用视图</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> user_summary;
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> mv_user_stats;

<span class="com">-- 删除视图</span>
<span class="kwd">DROP</span> <span class="kwd">VIEW</span> user_summary;
<span class="kwd">DROP</span> <span class="kwd">MATERIALIZED</span> <span class="kwd">VIEW</span> mv_user_stats;</code></pre>
                </div>

                <h3>4. 存储过程（支持 JavaScript）</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 传统存储过程</span>
<span class="kwd">DELIMITER</span> //
<span class="kwd">CREATE</span> <span class="kwd">PROCEDURE</span> get_users_by_age(<span class="kwd">IN</span> min_age <span class="kwd">INT</span>)
<span class="kwd">BEGIN</span>
    <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age >= min_age;
<span class="kwd">END</span> //
<span class="kwd">DELIMITER</span> ;

<span class="com">-- <span class="kwd">JavaScript</span> 存储过程（MySQL <span class="num">9</span>.x 新增）</span>
<span class="kwd">DELIMITER</span> //
<span class="kwd">CREATE</span> <span class="kwd">PROCEDURE</span> analyze_user_data()
<span class="kwd">LANGUAGE</span> <span class="kwd">JAVASCRIPT</span> <span class="kwd">AS</span>
$$
    const result = session.sql(<span class="str">'<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users'</span>).execute();
    const analysis = {
        total: result.length,
        avg_age: result.reduce((sum, row) => sum + row.age, <span class="num">0</span>) / result.length
    };
    <span class="kwd">return</span> JSON.stringify(analysis);
$$ //
<span class="kwd">DELIMITER</span> ;

<span class="com">-- 调用存储过程</span>
<span class="kwd">CALL</span> get_users_by_age(<span class="num">25</span>);
<span class="kwd">CALL</span> analyze_user_data();

<span class="com">-- 删除存储过程</span>
<span class="kwd">DROP</span> <span class="kwd">PROCEDURE</span> get_users_by_age;
<span class="kwd">DROP</span> <span class="kwd">PROCEDURE</span> analyze_user_data;</code></pre>
                </div>

                <h3>5. 触发器（支持批量操作）</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 创建触发器</span>
<span class="kwd">DELIMITER</span> //
<span class="kwd">CREATE</span> <span class="kwd">TRIGGER</span> before_user_insert
<span class="kwd">BEFORE</span> <span class="kwd">INSERT</span> <span class="kwd">ON</span> users
<span class="kwd">FOR EACH ROW</span>
<span class="kwd">BEGIN</span>
    <span class="kwd">IF</span> NEW.age < <span class="num">0</span> <span class="kwd">THEN</span>
        <span class="kwd">SET</span> NEW.age = <span class="num">0</span>;
    <span class="kwd">END</span> IF;
    <span class="kwd">IF</span> NEW.email <span class="kwd">IS</span> <span class="kwd">NULL</span> <span class="kwd">THEN</span>
        SIGNAL SQLSTATE <span class="str">'<span class="num">45000</span>'</span> <span class="kwd">SET</span> MESSAGE_TEXT = <span class="str">'Email 不能为空'</span>;
    <span class="kwd">END</span> IF;
<span class="kwd">END</span> //
<span class="kwd">DELIMITER</span> ;

<span class="com">-- 批量操作触发器（FOR EACH STATEMENT）</span>
<span class="kwd">DELIMITER</span> //
<span class="kwd">CREATE</span> <span class="kwd">TRIGGER</span> log_bulk_operation
<span class="kwd">AFTER</span> <span class="kwd">INSERT</span> <span class="kwd">ON</span> users
FOR EACH STATEMENT
<span class="kwd">BEGIN</span>
    <span class="kwd">INSERT</span> <span class="kwd">INTO</span> audit_log (operation, row_count, <span class="kwd">timestamp</span>)
    <span class="kwd">VALUES</span> (<span class="str">'BULK_INSERT'</span>, <span class="func">ROW_COUNT</span>(), <span class="func">NOW</span>());
<span class="kwd">END</span> //
<span class="kwd">DELIMITER</span> ;

<span class="com">-- 删除触发器</span>
<span class="kwd">DROP</span> <span class="kwd">TRIGGER</span> before_user_insert;</code></pre>
                </div>

                <h3>6. 连接查询（LATERAL JOIN）</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 内连接</span>
<span class="kwd">SELECT</span> u.username, o.order_id
<span class="kwd">FROM</span> users u
<span class="kwd">INNER JOIN</span> orders o <span class="kwd">ON</span> u.id = o.user_id;

<span class="com">-- <span class="kwd">LATERAL</span> JOIN（MySQL <span class="num">9</span>.x 新增）</span>
<span class="kwd">SELECT</span> u.username, latest_orders.*
<span class="kwd">FROM</span> users u
<span class="kwd">LEFT JOIN</span> <span class="kwd">LATERAL</span> (
    <span class="kwd">SELECT</span> o.order_id, o.total_amount
    <span class="kwd">FROM</span> orders o
    <span class="kwd">WHERE</span> o.user_id = u.id
    <span class="kwd">ORDER BY</span> o.order_date <span class="kwd">DESC</span>
    <span class="kwd">LIMIT</span> <span class="num">3</span>
) <span class="kwd">AS</span> latest_orders <span class="kwd">ON</span> TRUE;

<span class="com">-- 递归 CTE（查询层级数据）</span>
<span class="kwd">WITH</span> <span class="kwd">RECURSIVE</span> category_tree <span class="kwd">AS</span> (
    <span class="kwd">SELECT</span> id, name, parent_id, <span class="num">1</span> <span class="kwd">as</span> <span class="kwd">level</span>
    <span class="kwd">FROM</span> categories
    <span class="kwd">WHERE</span> parent_id <span class="kwd">IS</span> <span class="kwd">NULL</span>
    <span class="kwd">UNION</span> <span class="kwd">ALL</span>
    <span class="kwd">SELECT</span> c.id, c.name, c.parent_id, ct.<span class="kwd">level</span> + <span class="num">1</span>
    <span class="kwd">FROM</span> categories c
    <span class="kwd">INNER JOIN</span> category_tree ct <span class="kwd">ON</span> c.parent_id = ct.id
)
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> category_tree <span class="kwd">ORDER BY</span> <span class="kwd">level</span>, name;</code></pre>
                </div>
            </div>
        </section>

        <section id="index-theory" class="section">
            <h2>索引原理</h2>
            <div class="content">
                <h3>1. 索引概述</h3>
                <p>索引是数据库中用于加速数据检索的特殊数据结构。在 MySQL 中，索引本质上是帮助快速定位数据的数据结构，类似于书籍的目录。理解索引的实现原理对于设计高性能数据库至关重要。</p>

                <h3>2. B+ Tree 索引原理</h3>
                
                <h4>2.1 B+ Tree 结构</h4>
                <p>B+ Tree 是 MySQL 中 InnoDB 存储引擎默认使用的索引结构。它是一种自平衡的多路搜索树，所有数据都存储在叶子节点，非叶子节点只存储索引键。</p>
                
                <div class="mermaid">
graph TD
    subgraph 根节点
    R["[20 40 60 80]"]
    end
    
    subgraph 第一层节点
    L1_1["[10 15]"]
    L1_2["[20 30]"]
    L1_3["[40 50]"]
    L1_4["[60 70]"]
    L1_5["[80 90]"]
    end
    
    subgraph 叶子节点层
    L2_1["[1,5,8]<br/>→data1"]
    L2_2["[10,12,15]<br/>→data2"]
    L2_3["[20,25,30]<br/>→data3"]
    L2_4["[40,45,50]<br/>→data4"]
    L2_5["[60,65,70]<br/>→data5"]
    L2_6["[80,85,90]<br/>→data6"]
    end
    
    R --> L1_1
    R --> L1_2
    R --> L1_3
    R --> L1_4
    R --> L1_5
    
    L1_1 --> L2_1
    L1_1 --> L2_2
    L1_2 --> L2_2
    L1_2 --> L2_3
    L1_3 --> L2_3
    L1_3 --> L2_4
    L1_4 --> L2_4
    L1_4 --> L2_5
    L1_5 --> L2_5
    L1_5 --> L2_6
    
    L2_1 -.->|双向链表| L2_2
    L2_2 -.->|双向链表| L2_3
    L2_3 -.->|双向链表| L2_4
    L2_4 -.->|双向链表| L2_5
    L2_5 -.->|双向链表| L2_6
    
    style R fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style L1_1 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style L1_2 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style L1_3 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style L1_4 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style L1_5 fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    style L2_1 fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style L2_2 fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style L2_3 fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style L2_4 fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style L2_5 fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style L2_6 fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
</div>
                <p style="margin-top: 15px;"><strong>图示说明：</strong></p>
                <ul>
                    <li><strong style="color: #01579b;">蓝色节点</strong>：非叶子节点（索引页，仅存储键值）</li>
                    <li><strong style="color: #2e7d32;">绿色节点</strong>：叶子节点（数据页，存储完整数据）</li>
                    <li><strong>虚线</strong>：叶子节点间的双向链表连接</li>
                </ul>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- B+ Tree 结构特点：</span>
<span class="com">-- 1. 非叶子节点只存储索引键（冗余存储），不存储实际数据</span>
<span class="com">-- 2. 叶子节点存储所有数据（包含主键和所有列）</span>
<span class="com">-- 3. 叶子节点之间通过双向链表连接</span>
<span class="com">-- 4. 所有叶子节点深度相同，查询时间复杂度稳定 O(log n)</span>

<span class="com">-- 假设 B+ Tree 阶数 m=4：</span>
<span class="com">--        [50]              非叶子节点（索引键）</span>
<span class="com">--      /   |   \</span>
<span class="com">--   [10] [30] [50,70,90]  叶子节点（数据+链表）</span>
<span class="com">--    |    |    |</span>
<span class="com">--   ...  ...  ...</span></code></pre>
                </div>

                <h4>2.2 B+ Tree 查询过程</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 查询 id=50 的记录过程：</span>
<span class="com">-- 1. 从根节点开始，50 >= 50，进入中间子树</span>
<span class="com">-- 2. 比较 30 < 50 < 70，进入左侧叶子节点</span>
<span class="com">-- 3. 在叶子节点中顺序查找，找到目标记录</span>

<span class="com">-- B+ Tree 查询效率：</span>
<span class="com">-- - 高度通常为 2-3 层（百万级数据）</span>
<span class="com">-- - 每次 IO 可读取一个节点（约 16KB）</span>
<span class="com">-- - 磁盘 IO 次数 = 树高度 ≈ 3 次</span>

<span class="com">-- 对比全表扫描：需要读取所有数据页</span></code></pre>
                </div>

                <h4>2.3 B+ Tree vs B Tree</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- B+ Tree vs B Tree 对比：</span>
<span class="kwd">特性</span>           | <span class="kwd">B+ Tree</span>              | <span class="kwd">B Tree</span>
---------------|--------------------|----------------
数据存储       | 只在叶子节点        | 所有节点都存储数据
查询稳定性     | O(log n)，所有查询 | O(log n)，不同位置
<span class="kwd">范围查询</span>        | 叶子节点链表，<span class="kwd">高效</span>     | 需要遍历树
磁盘 IO        | 更少（只读叶子节点）| 更多
空间利用率     | 更高（节点满）      | 相对较低

<span class="com">-- 为什么 MySQL 选择 B+ Tree？</span>
<span class="com">-- 1. 范围查询更高效，适合 ORDER BY</span>
<span class="com">-- 2. 查询效率更稳定（都要到叶子节点）</span>
<span class="com">-- 3. 更适合磁盘存储，IO 次数少</span></code></pre>
                </div>

                <h3>3. 哈希索引原理</h3>
                
                <h4>3.1 哈希表结构</h4>
                <p>哈希索引使用哈希表实现，通过哈希函数将索引键转换为哈希值，然后用哈希值定位数据。哈希索引的查询时间复杂度为 O(1)，但只支持精确匹配查询。</p>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 哈希索引结构：</span>
<span class="com">-- 哈希函数：hash(key) -> hash_value</span>
<span class="com">-- 哈希表：bucket -> 指向数据行</span>

<span class="com">-- 示例：</span>
<span class="kwd">key</span> = <span class="str">'zhangsan'</span>
<span class="func">hash</span>(<span class="str">'zhangsan'</span>) = <span class="num">0x7f3a</span> (哈希值)
<span class="kwd">bucket</span>[<span class="num">0x7f3a</span>] -> [row1, row2] (哈希冲突链表)

<span class="com">-- 创建哈希索引（Memory/Heal 存储引擎）</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> t1 (
    id <span class="kwd">INT</span>,
    name <span class="type">VARCHAR</span>(<span class="num">100</span>),
    <span class="kwd">INDEX</span> idx_name (name) <span class="kwd">USING</span> <span class="kwd">HASH</span>
) ENGINE=MEMORY;</code></pre>
                </div>

                <h4>3.2 哈希索引的限制</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 哈希索引的限制：</span>
<span class="com">-- 1. 只支持等值查询，不支持范围查询</span>
SELECT * FROM users WHERE age > 25;  <span class="com">-- ❌ 无法使用哈希索引</span>
SELECT * FROM users WHERE name = 'zhangsan';  <span class="com">-- ✅ 可以使用</span>

<span class="com">-- 2. 不支持排序和前缀匹配</span>
SELECT * FROM users ORDER BY name;  <span class="com">-- ❌ 无法使用</span>
SELECT * FROM users WHERE name LIKE 'zhang%';  <span class="com">-- ❌ 无法使用</span>

<span class="com">-- 3. 哈希冲突导致性能下降</span>
<span class="com">-- 4. 无法避免回表查询</span>

<span class="com">-- InnoDB 自适应哈希索引 (AHI)</span>
<span class="com">-- InnoDB 会自动为热点数据创建哈希索引</span>
<span class="kwd">SHOW</span> ENGINE INNODB STATUS;  <span class="com">-- 查看自适应哈希索引状态</span></code></pre>
                </div>

                <h3>4. 全文索引原理</h3>
                
                <h4>4.1 倒排索引结构</h4>
                <p>全文索引采用倒排索引（Inverted Index）结构，与正向索引相反，倒排索引记录每个词条出现在哪些文档中。这使得全文搜索非常高效。</p>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 倒排索引结构：</span>
<span class="com">-- 正向索引：文档 -> [词条1, 词条2, ...]</span>
<span class="com">-- 倒排索引：词条 -> [文档1, 文档2, ...]</span>

<span class="com">-- 示例文档：</span>
<span class="str">Doc1</span>: <span class="str">"MySQL is a database"</span>
<span class="str">Doc2</span>: <span class="str">"MySQL is open source"</span>

<span class="com">-- 倒排索引：</span>
<span class="str">"MySQL"</span>   -> [<span class="str">Doc1</span>, <span class="str">Doc2</span>]
<span class="str">"is"</span>      -> [<span class="str">Doc1</span>, <span class="str">Doc2</span>]
<span class="str">"database"</span> -> [<span class="str">Doc1</span>]
<span class="str">"open"</span>     -> [<span class="str">Doc2</span>]
<span class="str">"source"</span>   -> [<span class="str">Doc2</span>]

<span class="com">-- 创建全文索引</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> articles (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    title <span class="type">VARCHAR</span>(<span class="num">200</span>),
    content <span class="type">TEXT</span>,
    <span class="kwd">FULLTEXT</span> <span class="kwd">INDEX</span> ft_idx (title, content) <span class="kwd">WITH</span> PARSER ngram
) ENGINE=InnoDB;</code></pre>
                </div>

                <h4>4.2 全文搜索机制</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 全文搜索模式：</span>
<span class="com">-- 1. NATURAL LANGUAGE MODE（自然语言模式）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> articles
<span class="kwd">WHERE</span> <span class="func">MATCH</span>(title, content) <span class="func">AGAINST</span>(<span class="str">'database'</span> <span class="kwd">IN</span> <span class="kwd">NATURAL</span> <span class="kwd">LANGUAGE</span> MODE);

<span class="com">-- 2. BOOLEAN MODE（布尔模式）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> articles
<span class="kwd">WHERE</span> <span class="func">MATCH</span>(title, content) <span class="func">AGAINST</span>(<span class="str">'+MySQL -database'</span> <span class="kwd">IN</span> BOOLEAN MODE);

<span class="com">-- 3. QUERY EXPANSION（查询扩展）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> articles
<span class="kwd">WHERE</span> <span class="func">MATCH</span>(title, content) <span class="func">AGAINST</span>(<span class="str">'MySQL'</span> <span class="kwd">WITH</span> <span class="kwd">QUERY</span> EXPANSION);

<span class="com">-- 4. ngram 分词器（中文）</span>
<span class="kwd">CREATE</span> <span class="kwd">FULLTEXT</span> <span class="kwd">INDEX</span> ft_zh <span class="kwd">ON</span> articles(content) <span class="kwd">WITH</span> PARSER ngram;</code></pre>
                </div>

                <h3>5. 空间索引原理</h3>
                
                <h4>5.1 R-Tree 结构</h4>
                <p>空间索引使用 R-Tree（区域树）结构，它是一种专门用于处理多维数据的树结构。R-Tree 将空间划分为层次嵌套的矩形区域，能够高效处理空间查询。</p>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- R-Tree 结构原理：</span>
<span class="com">-- 1. 空间被递归划分为嵌套的最小边界矩形 (MBR)</span>
<span class="com">-- 2. 每个节点存储子节点的 MBR</span>
<span class="com">-- 3. 叶子节点存储实际的空间对象</span>

<span class="com">-- R-Tree 示例：</span>
<span class="com">--        [MBR1]           根节点</span>
<span class="com">--      /   |   \</span>
<span class="com">--  [MBR2] [MBR3] [MBR4]  中间节点</span>
<span class="com">--   / \    |     / \</span>
<span class="com">-- P1  P2  P3   P4  P5    叶子节点（空间对象）</span>

<span class="com">-- 创建空间索引</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> locations (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    name <span class="type">VARCHAR</span>(<span class="num">100</span>),
    location GEOMETRY <span class="kwd">NOT</span> NULL</span>,
    <span class="kwd">SPATIAL</span> <span class="kwd">INDEX</span> idx_location (location)
) ENGINE=InnoDB;</code></pre>
                </div>

                <h4>5.2 空间查询类型</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 空间查询示例：</span>
<span class="com">-- 1. 包含查询：查找多边形内的点</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> locations
<span class="kwd">WHERE</span> <span class="func">ST_Contains</span>(
    <span class="func">ST_GeomFromText</span>(<span class="str">'POLYGON((0 0, 10 0, 10 10, 0 10, 0 0))'</span>),
    location
);

<span class="com">-- 2. 距离查询：查找距离某点一定范围内的对象</span>
<span class="kwd">SELECT</span> *, <span class="func">ST_Distance_Sphere</span>(location, <span class="func">ST_GeomFromText</span>(<span class="str">'POINT(116.4 39.9)'</span>))
<span class="kwd">FROM</span> locations
<span class="kwd">WHERE</span> <span class="func">ST_Distance_Sphere</span>(location, <span class="func">ST_GeomFromText</span>(<span class="str">'POINT(116.4 39.9)'</span>)) < <span class="num">50000</span>;

<span class="com">-- 3. 相交查询：查找相交的空间对象</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> locations
<span class="kwd">WHERE</span> <span class="func">ST_Intersects</span>(location, <span class="func">ST_GeomFromText</span>(<span class="str">'LINESTRING(0 0, 10 10)'</span>));</code></pre>
                </div>

                <h3>6. 聚簇索引 vs 非聚簇索引</h3>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>特性</th>
                                <th>聚簇索引</th>
                                <th>非聚簇索引</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>数据存储</td>
                                <td>数据行存储在叶子节点</td>
                                <td>叶子节点存储索引键+主键</td>
                            </tr>
                            <tr>
                                <td>数量限制</td>
                                <td>每个表只能有1个</td>
                                <td>每个表可以有多个</td>
                            </tr>
                            <tr>
                                <td>查询效率</td>
                                <td>查找主键直接返回数据</td>
                                <td>需要回表获取完整数据</td>
                            </tr>
                            <tr>
                                <td>磁盘顺序</td>
                                <td>数据按索引键物理排序</td>
                                <td>不影响数据物理顺序</td>
                            </tr>
                            <tr>
                                <td>适用场景</td>
                                <td>主键查询、范围查询</td>
                                <td>辅助查询、联合查询</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="mermaid">
flowchart TD
    A[SQL查询: SELECT * FROM users WHERE age = 25] --> B{使用哪个索引?}
    
    B -->|聚簇索引 PK| C[在主键索引中查找 id=1]
    C --> D[叶子节点包含完整数据]
    D --> E[直接返回结果]
    
    B -->|非聚簇索引 idx_age| F[在idx_age中查找 age=25]
    F --> G[获取主键 id=1]
    G --> H[回表: 在聚簇索引中查找id=1]
    H --> I[获取完整数据]
    I --> E
    
    style A fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style D fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style E fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style I fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
</div>
                
                <h4>6.1 聚簇索引（Clustered Index）</h4>
                <p>聚簇索引决定了数据的物理存储顺序。每个表只能有一个聚簇索引，因为数据只能按一种方式物理排序。通常主键就是聚簇索引。</p>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- InnoDB 聚簇索引特点：</span>
<span class="com">-- 1. 数据行直接存储在叶子节点中</span>
<span class="com">-- 2. 主键索引就是聚簇索引</span>
<span class="com">-- 3. 如果没有主键，使用第一个唯一非空索引</span>
<span class="com">-- 4. 如果没有唯一索引，InnoDB 会生成隐藏的 ROW_ID</span>

<span class="com">-- 聚簇索引结构：</span>
<span class="com">-- 叶子节点存储完整的数据行</span>
<span class="com">-- +--------+-------------+-----+-----+</span>
<span class="com">-- | id (PK)| name        | age | ... |</span>
<span class="com">-- +--------+-------------+-----+-----+</span>
<span class="com">-- | 1      | zhangsan    | 25  | ... |</span>
<span class="com">-- | 2      | lisi        | 30  | ... |</span>
<span class="com">-- | 3      | wangwu      | 28  | ... |</span>
<span class="com">-- +--------+-------------+-----+-----+</span>

<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> users (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,  <span class="com">-- 聚簇索引</span>
    name <span class="type">VARCHAR</span>(<span class="num">100</span>),
    age <span class="kwd">INT</span>,
    <span class="kwd">INDEX</span> idx_age (age)   <span class="com">-- 非聚簇索引</span>
);</code></pre>
                </div>

                <h4>6.2 非聚簇索引（Secondary Index）</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 非聚簇索引（辅助索引）特点：</span>
<span class="com">-- 1. 叶子节点存储索引键 + 主键值</span>
<span class="com">-- 2. 一个表可以有多个非聚簇索引</span>
<span class="com">-- 3. 查询时需要先通过非聚簇索引找到主键</span>
<span class="com">-- 4. 再通过主键到聚簇索引中获取完整数据（回表）</span>

<span class="com">-- 非聚簇索引 idx_age 结构：</span>
<span class="com">-- +--------+--------+</span>
<span class="com">-- | age    | id(PK) |</span>
<span class="com">-- +--------+--------+</span>
<span class="com">-- | 25     | 1      |</span>
<span class="com">-- | 28     | 3      |</span>
<span class="com">-- | 30     | 2      |</span>
<span class="com">-- +--------+--------+</span>

<span class="com">-- 查询 SELECT * FROM users WHERE age = 25：</span>
<span class="com">-- 1. 在 idx_age 中找到 age=25 的记录，获取 id=1</span>
<span class="com">-- 2. 在聚簇索引中找到 id=1 的完整数据</span>
<span class="com">-- 3. 返回完整数据行</span></code></pre>
                </div>

                <h4>6.3 覆盖索引避免回表</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 覆盖索引：索引包含查询所需的所有列</span>
<span class="com">-- 不需要回表，直接从索引中返回数据</span>

<span class="com">-- 创建覆盖索引</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_age_name <span class="kwd">ON</span> users(age, name);

<span class="com">-- 使用覆盖索引（不需要回表）</span>
<span class="kwd">SELECT</span> age, name <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span>;
<span class="com">-- EXPLAIN: Extra = Using index</span>

<span class="com">-- 需要回表的查询</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span>;
<span class="com">-- EXPLAIN: Extra = Using index condition</span>

<span class="com">-- 验证是否使用覆盖索引</span>
<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> age, name <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age = <span class="num">25</span>;
<span class="com">-- type=ref, key=idx_age_name, Extra=Using index</span></code></pre>
                </div>

                <h4>6.4 回表原理详解</h4>
                <p>回表是指查询过程中，先通过非聚簇索引找到主键值，再根据主键值到聚簇索引中查找完整数据行的过程。这是 InnoDB 存储引擎的重要特性。</p>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 回表的完整过程：</span>
<span class="com">-- 1. 在非聚簇索引树中查找</span>
<span class="com">-- 2. 获取满足条件的主键值</span>
<span class="com">-- 3. 使用主键值在聚簇索引中查找完整数据</span>
<span class="com">-- 4. 返回完整的用户数据</span>

<span class="com">-- 示例表结构：</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> orders (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,           <span class="com">-- 聚簇索引</span>
    order_no <span class="type">VARCHAR</span>(<span class="num">20</span>),       <span class="com">-- 唯一索引</span>
    customer_id <span class="kwd">INT</span>,
    amount <span class="kwd">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>),
    status <span class="type">VARCHAR</span>(<span class="num">10</span>),
    created_at <span class="type">DATETIME</span>,
    <span class="kwd">INDEX</span> idx_customer (customer_id) <span class="com">-- 非聚簇索引</span>
);

<span class="com">-- 执行 SELECT * FROM orders WHERE customer_id = 100</span>
<span class="com">-- 1. 在 idx_customer 中找到 customer_id=100 的记录</span>
<span class="com">-- 2. 获取主键 id（如 id=500）</span>
<span class="com">-- 3. 在聚簇索引中查找 id=500 的完整记录</span>
<span class="com">-- 4. 返回所有列数据</span>

<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> customer_id = <span class="num">100</span>;
<span class="com">-- type: ref, key: idx_customer</span>
<span class="com">-- Extra: Using index condition (需要回表)</span></code></pre>
                </div>

                <h4>6.5 回表性能影响</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 回表的性能影响：</span>
<span class="com">-- 1. 增加磁盘 IO：每次回表可能产生一次磁盘读取</span>
<span class="com">-- 2. 随机 IO：聚簇索引中查找是随机 IO</span>
<span class="com">-- 3. 回表次数 = 索引命中的记录数</span>

<span class="com">-- 回表次数过多的例子</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> customer_id > <span class="num">100</span>;
<span class="com">-- 假设 customer_id > 100 有 10000 条记录</span>
<span class="com">-- 需要回表 10000 次，性能很差</span>

<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> customer_id > <span class="num">100</span>;
<span class="com">-- type: range, key: idx_customer</span>
<span class="com">-- rows: 10000 (预计回表次数)</span>

<span class="com">-- 优化方案：使用覆盖索引</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_cover <span class="kwd">ON</span> orders(customer_id, order_no, amount, status);

<span class="com">-- 如果查询的列都在索引中，不需要回表</span>
<span class="kwd">SELECT</span> customer_id, order_no, amount, status 
<span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> customer_id > <span class="num">100</span>;

<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> customer_id, order_no, amount, status 
<span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> customer_id > <span class="num">100</span>;
<span class="com">-- Extra: Using index (覆盖索引，无需回表)</span></code></pre>
                </div>

                <h4>6.6 减少回表的方法</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 方法1：使用覆盖索引</span>
<span class="com">-- 将需要查询的列都包含在索引中</span>

<span class="com">-- 方法2：优化查询条件</span>
<span class="com">-- 避免返回大量数据</span>
<span class="kwd">SELECT</span> id, order_no <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> customer_id = <span class="num">100</span>
<span class="kwd">LIMIT</span> <span class="num">100</span>;  <span class="com">-- 限制返回数量</span>

<span class="com">-- 方法3：使用主键查询</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> id = <span class="num">500</span>;
<span class="com">-- 直接在聚簇索引中查找，不需要回表</span>

<span class="com">-- 方法4：分页优化</span>
<span class="com">-- 避免 OFFSET 过大导致的深度分页问题</span>

<span class="com">-- 低效（回表次数多）：</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">ORDER BY</span> id <span class="kwd">LIMIT</span> <span class="num">10000</span>, <span class="num">10</span>;

<span class="com">-- 高效（基于主键范围）：</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> id > <span class="num">10000</span> <span class="kwd">LIMIT</span> <span class="num">10</span>;
<span class="com">-- 上一页最后一条记录的 id 作为起点</span>

<span class="com">-- 方法5：使用延迟关联</span>
<span class="kwd">SELECT</span> o.* 
<span class="kwd">FROM</span> orders o 
<span class="kwd">INNER JOIN</span> (
    <span class="kwd">SELECT</span> id <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> customer_id = <span class="num">100</span>
    <span class="kwd">LIMIT</span> <span class="num">100</span>
) t <span class="kwd">ON</span> o.id = t.id;</code></pre>
                </div>

                <h3>7. 索引存储结构</h3>
                
                <h4>7.1 InnoDB 页面结构</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- InnoDB 数据页结构（默认 16KB）：</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | File Header      | 38 bytes - 文件头</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | Page Header      | 56 bytes - 页头</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | Infimum + Supremum| 26 bytes - 虚拟行</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | User Records     | 变长 - 用户数据</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | Free Space       | 变长 - 空闲空间</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | Page Directory   | 变长 - 页目录</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | File Trailer     | 8 bytes - 文件尾</span>
<span class="com">-- +------------------+</span>

<span class="com">-- 页内记录存储：</span>
<span class="com">-- 1. 记录头信息（变长字段长度、NULL标志等）</span>
<span class="com">-- 2. 记录实际数据</span>
<span class="com">-- 3. 记录通过 Page Directory 实现二分查找</span></code></pre>
                </div>

                <h4>7.2 索引页结构</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- B+ Tree 索引页结构：</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | File Header      | 38 bytes</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | Page Header      | 56 bytes</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | User Records     | 索引记录</span>
<span class="com">-- |  (非叶子节点)    | (最小键, 指向子页指针)</span>
<span class="com">-- |  (叶子节点)      | (键值, 主键/行指针)</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | Free Space       | 空闲空间</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | Page Directory   | 槽位目录（记录分组）</span>
<span class="com">-- +------------------+</span>
<span class="com">-- | File Trailer     | 8 bytes</span>
<span class="com">-- +------------------+</span>

<span class="com">-- 非叶子节点记录格式：</span>
<span class="com">-- | 记录头 | 索引键值 | 页面指针 |</span>

<span class="com">-- 叶子节点记录格式（聚簇索引）：</span>
<span class="com">-- | 记录头 | 主键值 | 其他列数据 |</span>

<span class="com">-- 叶子节点记录格式（非聚簇索引）：</span>
<span class="com">-- | 记录头 | 索引键值 | 主键值 |</span></code></pre>
                </div>

                <h3>8. 索引优化原理</h3>
                
                <h4>8.1 最左前缀原则</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 复合索引 (a, b, c) 的使用规则：</span>
<span class="kwd">WHERE</span> a = <span class="num">1</span>                 <span class="com">-- ✅ 使用索引 a</span>
<span class="kwd">WHERE</span> a = <span class="num">1</span> <span class="kwd">AND</span> b = <span class="num">2</span>        <span class="com">-- ✅ 使用索引 a, b</span>
<span class="kwd">WHERE</span> a = <span class="num">1</span> <span class="kwd">AND</span> b = <span class="num">2</span> <span class="kwd">AND</span> c = <span class="num">3</span>  <span class="com">-- ✅ 使用索引 a, b, c</span>
<span class="kwd">WHERE</span> b = <span class="num">2</span>                 <span class="com">-- ❌ 不使用索引</span>
<span class="kwd">WHERE</span> b = <span class="num">2</span> <span class="kwd">AND</span> c = <span class="num">3</span>    <span class="com">-- ❌ 不使用索引</span>
<span class="kwd">WHERE</span> a = <span class="num">1</span> <span class="kwd">AND</span> c = <span class="num">3</span>    <span class="com">-- ⚠️ 只使用索引 a</span>

<span class="com">-- 原理：复合索引按从左到右的顺序构建 B+ Tree</span>
<span class="com">-- 必须先使用前面的列，才能利用后续列的索引</span></code></pre>
                </div>

                <h4>8.2 索引下推（Index Condition Pushdown）</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 索引下推原理：</span>
<span class="com">-- 在 MySQL 5.6+ 之前：</span>
<span class="com">-- 1. 通过索引找到满足 a=1 的主键</span>
<span class="com">-- 2. 回表获取完整数据</span>
<span class="com">-- 3. 在 server 层过滤 b>100 的条件</span>

<span class="com">-- MySQL 5.6+ 索引下推：</span>
<span class="com">-- 1. 通过索引找到满足 a=1 的主键</span>
<span class="com">-- 2. 在存储引擎层直接过滤 b>100 的条件</span>
<span class="com">-- 3. 只对满足所有条件的记录回表</span>

<span class="com">-- 示例索引：(a, b)</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> t <span class="kwd">WHERE</span> a = <span class="num">1</span> <span class="kwd">AND</span> b > <span class="num">100</span>;

<span class="com">-- 验证索引下推</span>
<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> t <span class="kwd">WHERE</span> a = <span class="num">1</span> <span class="kwd">AND</span> b > <span class="num">100</span>;
<span class="com">-- Extra: Using index condition (使用了索引下推)</span></code></pre>
                </div>

                <h4>8.3 索引合并（Index Merge）</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 索引合并原理：</span>
<span class="com">-- MySQL 可以同时使用多个索引</span>
<span class="com">-- 然后合并结果集</span>

<span class="com">-- 索引合并类型：</span>
<span class="com">-- 1. intersection（交集）- 多个索引结果取交集</span>
<span class="com">-- 2. union（并集）- 多个索引结果取并集</span>
<span class="com">-- 3. sort_union（排序并集）- 先排序再取并集</span>

<span class="com">-- 示例：</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age = <span class="num">25</span> <span class="kwd">AND</span> name = <span class="str">'zhangsan'</span>;

<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age = <span class="num">25</span> <span class="kwd">AND</span> name = <span class="str">'zhangsan'</span>;
<span class="com">-- type: index_merge</span>
<span class="com">-- key: idx_age, idx_name</span>
<span class="com">-- Extra: Using intersect(idx_age,idx_name)</span></code></pre>
                </div>

                <h3>9. 索引实践分析</h3>
                
                <h4>9.1 使用 EXPLAIN 分析索引</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- EXPLAIN 关键字段：</span>
<span class="com">-- type: 连接类型（从好到差）</span>
<span class="com">--   system > const > eq_ref > ref > range > index > ALL</span>
<span class="com">--   const: 主键/唯一索引等值查询</span>
<span class="com">--   ref: 非唯一索引等值查询</span>
<span class="com">--   range: 索引范围查询</span>
<span class="com">--   index: 全索引扫描</span>
<span class="com">--   ALL: 全表扫描（需要优化）</span>

<span class="com">-- key: 实际使用的索引</span>
<span class="com">-- rows: 预计扫描的行数</span>
<span class="com">-- Extra: 额外信息</span>
<span class="com">--   Using index: 使用覆盖索引</span>
<span class="com">--   Using where: 使用 WHERE 条件过滤</span>
<span class="com">--   Using index condition: 使用索引下推</span>
<span class="com">--   Using filesort: 需要额外排序</span>
<span class="com">--   Using temporary: 使用临时表</span>

<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age = <span class="num">25</span>;

<span class="com">-- 分析结果：</span>
<span class="com">-- type: ref (使用了非唯一索引)</span>
<span class="com">-- key: idx_age</span>
<span class="com">-- rows: 10 (预计扫描 10 行)</span></code></pre>
                </div>

                <h4>9.2 索引设计最佳实践</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 索引设计原则：</span>
<span class="com">-- 1. 区分度高的列放在前面</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_status_user <span class="kwd">ON</span> orders(user_id, <span class="kwd">status</span>);
<span class="com">-- ✅ user_id 区分度高，放前面</span>

<span class="com">-- 2. 考虑查询的 WHERE 条件顺序</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_age_name <span class="kwd">ON</span> users(age, name);
<span class="com">-- 适合: WHERE age = ? 或 WHERE age = ? AND name = ?</span>

<span class="com">-- 3. 控制索引数量</span>
<span class="com">-- - 索引占用空间</span>
<span class="com">-- - 影响 INSERT/UPDATE/DELETE 性能</span>
<span class="com">-- - 建议单个表索引数 < 5</span>

<span class="com">-- 4. 使用覆盖索引减少回表</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_user_cover <span class="kwd">ON</span> orders(user_id, <span class="kwd">status</span>, created_at);
<span class="com">-- 覆盖: SELECT user_id, status FROM orders WHERE user_id = ?</span>

<span class="com">-- 5. 避免在区分度低的列上建索引</span>
<span class="com">-- 如: 性别、状态（0/1）等</span></code></pre>
                </div>
            </div>
        </section>

        <section id="performance" class="section">
            <h2>性能优化</h2>
            <div class="content">
                <h3>1. SQL 执行流程</h3>
                <p>了解SQL语句的执行流程有助于进行性能优化。以下是MySQL处理SQL查询的完整流程：</p>
                
                <div class="mermaid">
flowchart TD
    A[SQL语句] --> B[语法解析器]
    B --> C[语义检查]
    C --> D{查询缓存?}
    
    D -->|命中| E[直接返回缓存结果]
    D -->|未命中| F[查询优化器]
    
    F --> G[生成执行计划]
    G --> H[成本评估]
    H --> I[选择最优计划]
    
    I --> J[执行器]
    J --> K[存储引擎]
    K --> L[读取数据]
    L --> M[返回结果]
    
    M --> N[写入查询缓存]
    
    E --> O[返回客户端]
    N --> O
    
    style A fill:#fff3e0,stroke:#e65100,stroke-width:2px
    style F fill:#e3f2fd,stroke:#1565c0,stroke-width:2px
    style I fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
    style O fill:#c8e6c9,stroke:#2e7d32,stroke-width:2px
</div>
                
                <h4>各组件说明：</h4>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>组件</th>
                                <th>功能</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>语法解析器</td>
                                <td>将SQL解析为语法树，检查语法错误</td>
                            </tr>
                            <tr>
                                <td>语义检查</td>
                                <td>检查表、列是否存在，权限是否足够</td>
                            </tr>
                            <tr>
                                <td>查询缓存</td>
                                <td>缓存查询结果，避免重复执行</td>
                            </tr>
                            <tr>
                                <td>查询优化器</td>
                                <td>生成多种执行计划，选择最优方案</td>
                            </tr>
                            <tr>
                                <td>执行器</td>
                                <td>调用存储引擎执行计划</td>
                            </tr>
                            <tr>
                                <td>存储引擎</td>
                                <td>实际读取/写入数据 (InnoDB/MyISAM)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <h3>2. AI 查询优化器</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 启用 <span class="kwd">AI</span> 查询优化器</span>
<span class="kwd">SET</span> GLOBAL optimizer_switch = <span class="str">'ai_optimization=on'</span>;

<span class="com">-- 使用 <span class="kwd">AI</span> 优化提示</span>
<span class="kwd">SELECT</span> /*+ AI_OPTIMIZE */ * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span>;

<span class="com">-- 分析查询计划（<span class="kwd">AI</span> 增强版）</span>
<span class="kwd">EXPLAIN</span> <span class="kwd">ANALYZE</span> <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span>;

<span class="com">-- 查看 <span class="kwd">AI</span> 优化建议</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.ai_query_recommendations
<span class="kwd">WHERE</span> query_hash = <span class="func">MD5</span>(<span class="str">'YOUR_QUERY'</span>);

<span class="com">-- 自动应用优化建议</span>
<span class="kwd">CALL</span> sys.apply_ai_optimizations(<span class="str">'YOUR_QUERY_HASH'</span>);</code></pre>
                </div>

                <h3>2. 查询缓存优化</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 启用查询缓存（MySQL <span class="num">9</span>.x 智能缓存）</span>
<span class="kwd">SET</span> GLOBAL query_cache_type = ON;
<span class="kwd">SET</span> GLOBAL query_cache_size = <span class="num">67108864</span>; <span class="com">-- 64MB</span>

<span class="com">-- 监控缓存命中率</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> performance_schema.events_statements_summary_by_digest
<span class="kwd">ORDER BY</span> SUM_TIMER_WAIT <span class="kwd">DESC</span> <span class="kwd">LIMIT</span> <span class="num">10</span>;

<span class="com">-- 查看缓存统计</span>
<span class="kwd">SHOW</span> <span class="kwd">STATUS</span> <span class="kwd">LIKE</span> <span class="str">'Qcache%'</span>;</code></pre>
                </div>

                <details>
                    <summary>3. SQL 语句优化技巧（点击展开）</summary>

                <h4>3.1 避免全表扫描</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- ❌ 全表扫描（效率低）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age != <span class="num">25</span>;
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age <span class="kwd">NOT</span> <span class="kwd">IN</span> (<span class="num">20</span>, <span class="num">30</span>);

<span class="com">-- ✅ 使用索引（效率高）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age = <span class="num">25</span>;

<span class="com">-- ❌ 前导通配符（无法使用索引）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> name <span class="kwd">LIKE</span> <span class="str">'%zhang%'</span>;

<span class="com">-- ✅ 后置通配符（可以使用索引）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> name <span class="kwd">LIKE</span> <span class="str">'zhang%'</span>;

<span class="com">-- ✅ 使用覆盖索引</span>
<span class="kwd">SELECT</span> name, age <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> name <span class="kwd">LIKE</span> <span class="str">'zhang%'</span>;</code></pre>
                </div>

                <h4>3.2 优化 LIMIT 分页</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- ❌ 低效的分页（深度分页问题）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">ORDER BY</span> id <span class="kwd">LIMIT</span> <span class="num">100000</span>, <span class="num">10</span>;
<span class="com">-- MySQL 会先扫描前 100010 条记录，然后丢弃前 100000 条</span>

<span class="com">-- ✅ 优化方案1：基于主键的范围查询</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders 
<span class="kwd">WHERE</span> id > <span class="num">100000</span> 
<span class="kwd">ORDER BY</span> id 
<span class="kwd">LIMIT</span> <span class="num">10</span>;

<span class="com">-- ✅ 优化方案2：延迟关联</span>
<span class="kwd">SELECT</span> o.*
<span class="kwd">FROM</span> orders o
<span class="kwd">INNER JOIN</span> (
    <span class="kwd">SELECT</span> id <span class="kwd">FROM</span> orders
    <span class="kwd">ORDER BY</span> id
    <span class="kwd">LIMIT</span> <span class="num">100000</span>, <span class="num">10</span>
) t <span class="kwd">ON</span> o.id = t.id;

<span class="com">-- ✅ 优化方案3：记录上一页最后一条 ID</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders 
<span class="kwd">WHERE</span> id > <span class="num">100000</span> 
<span class="kwd">ORDER BY</span> id 
<span class="kwd">LIMIT</span> <span class="num">10</span>;
<span class="com">-- 假设上一页最后一条是 id=100000</span></code></pre>
                </div>

                <h4>3.3 避免 SELECT *</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- ❌ SELECT * 会读取所有列，增加 IO</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> customer_id = <span class="num">100</span>;

<span class="com">-- ✅ 只查询需要的列</span>
<span class="kwd">SELECT</span> order_no, amount, created_at 
<span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> customer_id = <span class="num">100</span>;

<span class="com">-- ✅ 使用覆盖索引时，效果更明显</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_cover <span class="kwd">ON</span> orders(customer_id, order_no, amount);
<span class="kwd">SELECT</span> order_no, amount <span class="kwd">FROM</span> orders <span class="kwd">WHERE</span> customer_id = <span class="num">100</span>;
<span class="com">-- 完全在索引中完成，不需要回表</span></code></pre>
                </div>

                <h4>3.4 合理使用 JOIN</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- ❌ 大表 JOIN 小表（效率低）</span>
<span class="kwd">SELECT</span> o.*, c.name
<span class="kwd">FROM</span> orders o  <span class="com">-- 大表</span>
<span class="kwd">LEFT</span> <span class="kwd">JOIN</span> customers c <span class="kwd">ON</span> o.customer_id = c.id;

<span class="com">-- ✅ 使用小表驱动大表（EXPLAIN 中 type 最好）</span>
<span class="kwd">SELECT</span> o.*, c.name
<span class="kwd">FROM</span> customers c  <span class="com">-- 小表</span>
<span class="kwd">LEFT</span> <span class="kwd">JOIN</span> orders o <span class="kwd">ON</span> o.customer_id = c.id;

<span class="com">-- 确保 JOIN 条件有索引</span>
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_order_customer <span class="kwd">ON</span> orders(customer_id);
<span class="kwd">CREATE</span> <span class="kwd">INDEX</span> idx_customer_id <span class="kwd">ON</span> customers(id);

<span class="com">-- 避免多表 JOIN，适当拆分为多个查询</span></code></pre>
                </div>

                <h4>3.5 批量操作优化</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- ❌ 逐条插入（效率低）</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> users (name) <span class="kwd">VALUES</span> (<span class="str">'a'</span>);
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> users (name) <span class="kwd">VALUES</span> (<span class="str">'b'</span>);
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> users (name) <span class="kwd">VALUES</span> (<span class="str">'c'</span>);

<span class="com">-- ✅ 批量插入（效率高）</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> users (name) <span class="kwd">VALUES</span>
    (<span class="str">'a'</span>), (<span class="str">'b'</span>), (<span class="str">'c'</span>), (<span class="str">'d'</span>), (<span class="str">'e'</span>);

<span class="com">-- 批量插入建议每次 1000-5000 条</span>

<span class="com">-- 禁用索引加速批量插入</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users <span class="kwd">DISABLE</span> KEYS;
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> users (name) <span class="kwd">VALUES</span> ...;  <span class="com">-- 批量插入</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> users <span class="kwd">ENABLE</span> KEYS;

<span class="com">-- 使用 LOAD DATA INFILE（最快）</span>
<span class="kwd">LOAD</span> DATA INFILE <span class="str">'/path/to/file.csv'</span>
<span class="kwd">INTO</span> TABLE users
FIELDS TERMINATED BY <span class="str">','</span>
LINES TERMINATED BY <span class="str">'\n'</span>
(name);</code></pre>
                </div>
                </details>

                <h3>4. 常用配置优化</h3>

                <h4>4.1 缓冲区配置</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- InnoDB 缓冲池大小（建议设置为可用内存的 60-80%）</span>
<span class="kwd">SET</span> GLOBAL innodb_buffer_pool_size = <span class="num">4294967296</span>;  <span class="com">-- 4GB</span>

<span class="com">-- 缓冲池实例数量（多核CPU建议设置多个实例）</span>
<span class="kwd">SET</span> GLOBAL innodb_buffer_pool_instances = <span class="num">4</span>;

<span class="com">-- 日志文件大小</span>
<span class="kwd">SET</span> GLOBAL innodb_log_file_size = <span class="num">1073741824</span>;  <span class="com">-- 1GB</span>

<span class="com">-- 刷新日志频率（平衡性能和数据安全）</span>
<span class="kwd">SET</span> GLOBAL innodb_flush_log_at_trx_commit = <span class="num">2</span>;
<span class="com">-- 1: 每次事务刷新（最安全，默认）</span>
<span class="com">-- 2: 每秒刷新（性能好，崩溃可能丢失1秒数据）</span>
<span class="com">-- 0: 不立即刷新（最快，崩溃可能丢失大量数据）</span></code></pre>
                </div>

                <h4>4.2 连接配置</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 最大连接数</span>
<span class="kwd">SET</span> GLOBAL max_connections = <span class="num">500</span>;

<span class="com">-- 连接超时时间</span>
<span class="kwd">SET</span> GLOBAL wait_timeout = <span class="num">600</span>;  <span class="com">-- 10分钟</span>
<span class="kwd">SET</span> GLOBAL interactive_timeout = <span class="num">600</span>;

<span class="com">-- 线程缓存大小</span>
<span class="kwd">SET</span> GLOBAL thread_cache_size = <span class="num">50</span>;

<span class="com">-- 查询缓存大小</span>
<span class="kwd">SET</span> GLOBAL query_cache_size = <span class="num08864</span">671>;  <span class="com">-- 64MB</span>
<span class="kwd">SET</span> GLOBAL query_cache_limit = <span class="num">1048576</span>;  <span class="com">-- 单个查询最大1MB</span></code></pre>
                </div>

                <h4>4.3 临时表和排序缓冲</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 临时表大小</span>
<span class="kwd">SET</span> GLOBAL tmp_table_size = <span class="num">134217728</span>;  <span class="com">-- 128MB</span>
<span class="kwd">SET</span> GLOBAL max_heap_table_size = <span class="num">134217728</span>;

<span class="com">-- 排序缓冲大小</span>
<span class="kwd">SET</span> GLOBAL sort_buffer_size = <span class="num">4194304</span>;  <span class="com">-- 4MB</span>

<span class="com">-- 读取缓冲大小</span>
<span class="kwd">SET</span> GLOBAL read_buffer_size = <span class="num">2097152</span>;  <span class="com">-- 2MB</span>
<span class="kwd">SET</span> GLOBAL read_rnd_buffer_size = <span class="num">4194304</span>;  <span class="com">-- 4MB</span>

<span class="com">-- 查看配置</span>
<span class="kwd">SHOW</span> VARIABLES LIKE <span class="str">'%buffer%'</span>;
<span class="kwd">SHOW</span> VARIABLES LIKE <span class="str">'%size%'</span>;</code></pre>
                </div>

                <h3>5. 慢查询分析</h3>

                <h4>5.1 开启慢查询日志</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 开启慢查询日志</span>
<span class="kwd">SET</span> GLOBAL slow_query_log = <span class="str">'ON'</span>;
<span class="kwd">SET</span> GLOBAL slow_query_log_file = <span class="str">'/var/log/mysql/slow.log'</span>;
<span class="kwd">SET</span> GLOBAL long_query_time = <span class="num">1</span>;  <span class="com">-- 超过1秒记录</span>
<span class="kwd">SET</span> GLOBAL log_queries_not_using_indexes = <span class="str">'ON'</span>;

<span class="com">-- 查看慢查询</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> mysql.slow_log
<span class="kwd">ORDER BY</span> start_time DESC
<span class="kwd">LIMIT</span> <span class="num">10</span>;

<span class="com">-- 使用 mysqldumpslow 工具分析</span>
<span class="com">-- mysqldumpslow -s t -t 10 /var/log/mysql/slow.log</span>
<span class="com">-- -s: 排序方式 (t=时间, c=次数)</span>
<span class="com">-- -t: 显示前N条</span></code></pre>
                </div>

                <h4>5.2 使用 EXPLAIN 分析</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- EXPLAIN 分析查询计划</span>
<span class="kwd">EXPLAIN</span> <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span>;

<span class="com">-- 关键字段解读：</span>
<span class="com">-- type: 连接类型</span>
<span class="com">--   system > const > eq_ref > ref > range > index > ALL</span>
<span class="com">--   const/eq_ref/ref/range 都是可接受的</span>
<span class="com">--   ALL 表示全表扫描，需要优化</span>

<span class="com">-- key: 实际使用的索引</span>
<span class="com">-- rows: 预计扫描的行数（越小越好）</span>
<span class="com">-- Extra: 额外信息</span>
<span class="com">--   Using index: 使用覆盖索引</span>
<span class="com">--   Using filesort: 需要额外排序</span>
<span class="com">--   Using temporary: 使用临时表</span>

<span class="com">-- EXPLAIN ANALYZE（实际执行并分析）</span>
<span class="kwd">EXPLAIN</span> ANALYZE <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span>;</code></pre>
                </div>

                <h3>6. 表结构优化</h3>

                <h4>6.1 选择合适的数据类型</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- ❌ 使用过大的数据类型</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> t1 (
    id <span class="type">INT</span>,           <span class="com">-- 4字节</span>
    phone <span class="type">VARCHAR</span>(<span class="num">20</span>)
);

<span class="com">-- ✅ 使用合适的数据类型</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> t2 (
    id <span class="kwd">INT</span> <span class="kwd">UNSIGNED</span>,     <span class="com">-- 无符号，支持更大范围</span>
    status <span class="kwd">TINYINT</span>,        <span class="com">-- 1字节，范围 -128~127</span>
    age <span class="kwd">TINYINT</span> <span class="kwd">UNSIGNED</span>, <span class="com">-- 0-255</span>
    views <span class="kwd">BIGINT</span> <span class="kwd">UNSIGNED</span>,  <span class="com">-- 大访问量</span>
    price <span class="type">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>)  <span class="com">-- 精确价格</span>
);

<span class="com">-- 使用 ENUM 代替字符串</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> orders (
    status <span class="kwd">ENUM</span>(<span class="str">'pending'</span>, <span class="str">'processing'</span>, <span class="str">'completed'</span>, <span class="str">'cancelled'</span>)
);

<span class="com">-- 使用 NOT NULL</span>
<span class="com">-- NULL 需要额外空间存储，且影响索引效率</span></code></pre>
                </div>

                <h4>6.2 垂直拆分和水平拆分</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 垂直拆分：将大表拆分为多个小表</span>
<span class="com">-- 原始表：users (id, name, email, avatar, bio, ...) 字段很多</span>

<span class="com">-- 拆分后：</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> users (
    id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    name <span class="type">VARCHAR</span>(<span class="num">50</span>),
    email <span class="type">VARCHAR</span>(<span class="num">100</span>)
);

<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> user_profiles (
    user_id <span class="kwd">INT</span> <span class="kwd">PRIMARY KEY</span>,
    avatar <span class="type">VARCHAR</span>(<span class="num">255</span>),
    bio <span class="type">TEXT</span>,
    <span class="kwd">FOREIGN</span> <span class="kwd">KEY</span> (user_id) <span class="kwd">REFERENCES</span> users(id)
);

<span class="com">-- 水平拆分：按数据范围或哈希分表</span>
<span class="com">-- 按月份分表（适用于日志、订单等）</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> orders_202401 (
    <span class="kwd">LIKE</span> orders
);

<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> orders_202402 (
    <span class="kwd">LIKE</span> orders
);

<span class="com">-- 使用分区表（MySQL 原生支持）</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> orders_partitioned (
    id <span class="kwd">INT</span>,
    created_at <span class="type">DATE</span>,
    amount <span class="type">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>)
) PARTITION BY <span class="kwd">RANGE</span> (YEAR(created_at)) (
    PARTITION p2023 <span class="kwd">VALUES</span> LESS THAN (<span class="num">2024</span>),
    PARTITION p2024 <span class="kwd">VALUES</span> LESS THAN (<span class="num">2025</span>),
    PARTITION pmax <span class="kwd">VALUES</span> LESS THAN <span class="kwd">MAXVALUE</span>
);</code></pre>
                </div>

                <h3>7. 读写分离与负载均衡</h3>
                
                <div class="mermaid">
sequenceDiagram
    participant App as 应用服务器
    participant Master as 主库 (Master)
    participant Slave1 as 从库 (Slave1)
    participant Slave2 as 从库 (Slave2)
    
    App->>Master: 1. INSERT/UPDATE/DELETE
    Master->>Master: 写入binlog
    Master-->>App: 返回成功
    
    par 异步复制
        Master->>Slave1: 2. 传输binlog
        Master->>Slave2: 2. 传输binlog
    end
    
    Slave1->>Slave1: 3. 重放binlog
    Slave2->>Slave2: 3. 重放binlog
    
    Note over App,Master: 读写分离: 写操作→主库, 读操作→从库
    
    App->>Slave1: 4. SELECT查询
    Slave1-->>App: 返回查询结果
    
    App->>Slave2: 5. SELECT查询
    Slave2-->>App: 返回查询结果
</div>
                
                <h4>主从复制原理：</h4>
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>步骤</th>
                                <th>主库操作</th>
                                <th>从库操作</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>1. 日志记录</td>
                                <td>将写操作记录到 binlog</td>
                                <td>-</td>
                            </tr>
                            <tr>
                                <td>2. 日志传输</td>
                                <td>将 binlog 发送到从库</td>
                                <td>接收 binlog</td>
                            </tr>
                            <tr>
                                <td>3. 日志重放</td>
                                <td>-</td>
                                <td>执行 binlog 中的操作</td>
                            </tr>
                            <tr>
                                <td>4. 同步完成</td>
                                <td>-</td>
                                <td>更新 relay log 位置</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <h4>7.1 主从复制配置</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 主库配置</span>
<span class="kwd">[mysqld]
server-id = <span class="num">1</span>
log-bin = mysql-bin
binlog-do-db = myapp

<span class="com">-- 从库配置</span>
<span class="kwd">[mysqld]
server-id = <span class="num">2</span>
relay-log = relay-bin
read-only = <span class="num">1</span>

<span class="com">-- 从库设置</span>
<span class="kwd">CHANGE</span> MASTER <span class="kwd">TO</span>
    MASTER_HOST=<span class="str">'master_host'</span>,
    MASTER_USER=<span class="str">'repl_user'</span>,
    MASTER_PASSWORD=<span class="str">'password'</span>,
    MASTER_LOG_FILE=<span class="str">'mysql-bin.000001'</span>,
    MASTER_LOG_POS=<span class="num">154</span>;

<span class="kwd">START</span> SLAVE;
<span class="kwd">SHOW</span> SLAVE STATUS\G</code></pre>
                </div>

                <h4>7.2 连接池配置</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 推荐使用连接池（推荐 HikariCP、Druid）</span>
<span class="com">-- 连接池配置建议：</span>

<span class="com">-- 最小空闲连接数</span>
minimum-idle = <span class="num">5</span>

<span class="com">-- 最大连接数</span>
maximum-pool-size = <span class="num">20</span>

<span class="com">-- 空闲连接超时（毫秒）</span>
idle-timeout = <span class="num">300000</span>

<span class="com">-- 连接最大生命周期（毫秒）</span>
max-lifetime = <span class="num">1800000</span>

<span class="com">-- 连接超时（毫秒）</span>
connection-timeout = <span class="num">30000</span></code></pre>
                </div>

                <h3>3. 并发控制</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 查看当前锁情况</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> performance_schema.data_locks;

<span class="com">-- 设置事务隔离级别（支持新的隔离级别）</span>
<span class="kwd">SET</span> TRANSACTION <span class="kwd">ISOLATION</span> <span class="kwd">LEVEL</span> READ COMMITTED;

<span class="com">-- 乐观锁（改进的版本控制）</span>
<span class="kwd">UPDATE</span> products
<span class="kwd">SET</span> stock = stock - <span class="num">1</span>, <span class="kwd">version</span> = <span class="kwd">version</span> + <span class="num">1</span>
<span class="kwd">WHERE</span> id = <span class="num">1</span> <span class="kwd">AND</span> <span class="kwd">version</span> = <span class="num">5</span>;

<span class="com">-- 查看行锁等待</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> performance_schema.events_waits_current
<span class="kwd">WHERE</span> EVENT_NAME <span class="kwd">LIKE</span> <span class="str">'%lock%'</span>;</code></pre>
                </div>

                <h3>4. 性能监控</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 实时性能监控</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.statements_with_runtimes_in_95th_percentile;

<span class="com">-- 查看慢查询（<span class="kwd">AI</span> 分析）</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.statements_with_temp_tables
<span class="kwd">ORDER BY</span> tmp_tables DESC;

<span class="com">-- 表空间使用情况</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> information_schema.innodb_tablespaces;

<span class="com">-- <span class="kwd">AI</span> 性能诊断报告</span>
<span class="kwd">CALL</span> sys.generate_performance_report(<span class="str">'your_database'</span>);</code></pre>
                </div>
            </div>
        </section>

        <section id="security" class="section">
            <h2>安全特性</h2>
            <div class="content">
                <h3>1. 零信任架构</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 启用零信任架构</span>
<span class="kwd">SET</span> GLOBAL require_secure_transport = ON;
<span class="kwd">SET</span> GLOBAL validate_password.<span class="kwd">policy</span> = STRONG;

<span class="com">-- 创建用户（支持多因素认证）</span>
<span class="kwd">CREATE</span> USER <span class="str">'admin'</span>@<span class="str">'%'</span> IDENTIFIED <span class="kwd">BY</span> <span class="str">'password'</span>
<span class="kwd">WITH</span> MAX_QUERIES_PER_HOUR <span class="num">1000</span>
MAX_UPDATES_PER_HOUR <span class="num">100</span>
MAX_CONNECTIONS_PER_HOUR <span class="num">100</span>
MAX_USER_CONNECTIONS <span class="num">10</span>;

<span class="com">-- 启用 MFA</span>
<span class="kwd">ALTER</span> USER <span class="str">'admin'</span>@<span class="str">'%'</span> <span class="kwd">REQUIRE</span> MFA;

<span class="com">-- 角色管理（改进的 RBAC）</span>
<span class="kwd">CREATE</span> <span class="kwd">ROLE</span> <span class="str">'developer'</span>, <span class="str">'analyst'</span>;
GRANT <span class="kwd">SELECT</span>, <span class="kwd">INSERT</span>, <span class="kwd">UPDATE</span> <span class="kwd">ON</span> app_database.* TO <span class="str">'developer'</span>;
GRANT <span class="kwd">SELECT</span> <span class="kwd">ON</span> app_database.* TO <span class="str">'analyst'</span>;

GRANT <span class="str">'developer'</span> TO <span class="str">'user1'</span>@<span class="str">'%'</span>;
<span class="kwd">SET</span> <span class="kwd">DEFAULT</span> <span class="kwd">ROLE</span> <span class="kwd">ALL</span> TO <span class="str">'user1'</span>@<span class="str">'%'</span>;</code></pre>
                </div>

                <h3>2. 数据加密</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 透明数据加密（TDE）</span>
<span class="kwd">ALTER</span> INSTANCE <span class="kwd">ROTATE</span> INNODB <span class="kwd">MASTER</span> KEY;

<span class="com">-- 列级加密</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> sensitive_data (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    credit_card <span class="type">VARCHAR</span>(<span class="num">100</span>) <span class="kwd">ENCRYPTED</span> <span class="kwd">WITH</span> <span class="str">'AES256-CBC'</span>
);

<span class="com">-- 查询加密数据（自动解密）</span>
<span class="kwd">SELECT</span> id, <span class="func">AES_DECRYPT</span>(credit_card, <span class="str">'encryption_key'</span>) <span class="kwd">as</span> card_number
<span class="kwd">FROM</span> sensitive_data;

<span class="com">-- 审计日志（增强版）</span>
<span class="kwd">SET</span> GLOBAL audit_log_policy = ALL;
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> performance_schema.events_statements_history_long;</code></pre>
                </div>

                <h3>3. 访问控制</h3>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 基于时间的访问控制</span>
<span class="kwd">CREATE</span> USER <span class="str">'temp_user'</span>@<span class="str">'%'</span> IDENTIFIED <span class="kwd">BY</span> <span class="str">'password'</span>
<span class="kwd">WITH</span> VALID_UNTIL <span class="str">'<span class="num">2027</span>-<span class="num">12</span>-<span class="num">31</span> <span class="num">23</span>:<span class="num">59</span>:<span class="num">59</span>'</span>;

<span class="com">-- 行级安全策略（Row-<span class="kwd">Level</span> Security）</span>
<span class="kwd">CREATE</span> <span class="kwd">POLICY</span> user_isolation <span class="kwd">ON</span> users
FOR <span class="kwd">SELECT</span>
USING (user_id = <span class="func">CURRENT_USER_ID</span>());

<span class="com">-- 查看权限</span>
<span class="kwd">SHOW</span> GRANTS FOR <span class="str">'user1'</span>@<span class="str">'%'</span>;</code></pre>
                </div>
            </div>
        </section>

        <section id="ai" class="section">
            <h2>AI 增强功能</h2>
            <div class="content">
                <h3>1. AI 查询优化器</h3>
                
                <h4>1.1 传统查询优化器 vs AI 优化器</h4>
                <p>MySQL 9.x 引入了基于机器学习的查询优化器，能够通过分析历史查询模式和统计信息，自动选择最优的执行计划。</p>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 传统优化器基于成本模型</span>
<span class="com">-- AI 优化器基于历史数据和预测模型</span>

<span class="com">-- 启用 AI 优化器</span>
<span class="kwd">SET</span> GLOBAL optimizer_switch = <span class="str">'ai_optimization=on'</span>;

<span class="com">-- 查看当前优化器设置</span>
<span class="kwd">SHOW</span> VARIABLES LIKE <span class="str">'optimizer_switch'</span>;

<span class="com">-- 为特定查询启用 AI 优化</span>
<span class="kwd">SELECT</span> /*+ AI_OPTIMIZE */ *
<span class="kwd">FROM</span> orders o
<span class="kwd">JOIN</span> customers c <span class="kwd">ON</span> o.customer_id = c.id
<span class="kwd">WHERE</span> o.created_at > <span class="str">'2024-01-01'</span>
<span class="kwd">ORDER BY</span> o.total_amount DESC
<span class="kwd">LIMIT</span> <span class="num">100</span>;</code></pre>
                </div>

                <h4>1.2 AI 优化器工作原理</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- AI 优化器的工作流程：</span>
<span class="com">-- 1. 收集历史查询执行数据</span>
<span class="com">-- 2. 构建查询特征模型</span>
<span class="com">-- 3. 预测不同执行计划的成本</span>
<span class="com">-- 4. 选择最优执行计划</span>

<span class="com">-- 查看 AI 优化器的分析结果</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.ai_query_analysis
<span class="kwd">WHERE</span> query_time > <span class="func">NOW</span>() - INTERVAL <span class="num">1</span> DAY
<span class="kwd">ORDER BY</span> execution_time DESC;

<span class="com">-- 查看执行计划预测</span>
<span class="kwd">EXPLAIN</span> ANALYZE <span class="kwd">SELECT</span> * <span class="kwd">FROM</span> users <span class="kwd">WHERE</span> age > <span class="num">25</span>;

<span class="com">-- AI 优化的统计信息</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.ai_optimizer_stats;</code></pre>
                </div>

                <details>
                    <summary>2. 机器学习集成（点击展开）</summary>

                <h4>2.1 内置 ML 模型</h4>
                <p>MySQL 9.x 支持直接在数据库中创建、训练和使用机器学习模型，实现端到端的 ML 工作流。无需将数据导出到外部 ML 平台，在数据库内部即可完成从数据准备到模型部署的全流程。</p>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>算法类型</th>
                                <th>支持算法</th>
                                <th>适用场景</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>分类</strong></td>
                                <td>逻辑回归、随机森林、梯度提升、XGBoost</td>
                                <td>用户流失预测、欺诈检测、垃圾邮件识别</td>
                            </tr>
                            <tr>
                                <td><strong>回归</strong></td>
                                <td>线性回归、岭回归、随机森林回归</td>
                                <td>销量预测、价格预测、评分预测</td>
                            </tr>
                            <tr>
                                <td><strong>聚类</strong></td>
                                <td>K-Means、DBSCAN、高斯混合模型</td>
                                <td>用户分群、异常检测、文档分类</td>
                            </tr>
                            <tr>
                                <td><strong>推荐</strong></td>
                                <td>协同过滤、矩阵分解</td>
                                <td>商品推荐、内容推荐、用户相似度</td>
                            </tr>
                            <tr>
                                <td><strong>时间序列</strong></td>
                                <td>ARIMA、Prophet、LSTM</td>
                                <td>需求预测、趋势分析、异常检测</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="mermaid">
flowchart LR
    subgraph 数据准备
        A[原始数据] --> B[数据清洗]
        B --> C[特征工程]
        C --> D[训练数据]
    end
    
    subgraph 模型训练
        D --> E[选择算法]
        E --> F[超参数调优]
        F --> G[交叉验证]
        G --> H[模型训练]
    end
    
    subgraph 模型评估
        H --> I[模型评估]
        I --> J{评估通过?}
    end
    
    subgraph 部署预测
        J -->|是| K[部署上线]
        K --> L[实时预测]
        L --> M[业务应用]
    end
    
    J -->|否| E
    
    style A fill:#e3f2fd,stroke:#1565c0
    style H fill:#c8e6c9,stroke:#2e7d32
    style K fill:#fff3e0,stroke:#e65100
    style M fill:#e1f5fe,stroke:#01579b
</div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 查看支持的 ML 算法</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.ml_available_algorithms;

<span class="com">-- 创建训练数据表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> customer_features (
    customer_id <span class="kwd">INT PRIMARY KEY</span>,
    age <span class="kwd">INT</span>,
    income <span class="kwd">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>),
    purchase_frequency <span class="kwd">INT</span>,
    avg_order_value <span class="kwd">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>),
    days_since_last_purchase <span class="kwd">INT</span>,
    total_orders <span class="kwd">INT</span>,
    avg_review_score <span class="kwd">DECIMAL</span>(<span class="num">3</span>,<span class="num">2</span>),
    churn_label <span class="kwd">TINYINT</span>
);

<span class="com">-- 特征工程：创建衍生特征</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> customer_features
ADD COLUMN customer_lifetime_value <span class="kwd">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>)
GENERATED ALWAYS <span class="kwd">AS</span> (total_orders * avg_order_value);

<span class="com">-- 创建机器学习模型 - 梯度提升分类器</span>
<span class="kwd">CREATE</span> ML <span class="kwd">MODEL</span> customer_churn_model
<span class="kwd">FROM</span> customer_features
FEATURES (age, income, purchase_frequency, avg_order_value, days_since_last_purchase, total_orders, avg_review_score, customer_lifetime_value)
TARGET (churn_label)
ALGORITHM <span class="str">'gradient_boosting'</span>
OPTIONS (
    n_estimators = <span class="num">100</span>,
    max_depth = <span class="num">5</span>,
    learning_rate = <span class="num">0.1</span>,
    min_samples_split = <span class="num">20</span>,
    test_size = <span class="num">0.2</span>
);</code></pre>
                </div>
                
                <h4>2.2 模型预测</h4>
                <p>训练完成的模型可直接用于预测，支持实时预测和批量预测两种模式。</p>
                
                <div class="mermaid">
flowchart TD
    subgraph 实时预测流程
        A[前端请求] --> B[API网关]
        B --> C[提取特征]
        C --> D[ML模型推理]
        D --> E[返回预测结果]
        E --> F[业务处理]
    end
    
    subgraph 批量预测流程
        G[定时任务] --> H[批量数据]
        H --> I[分批处理]
        I --> J[批量推理]
        J --> K[结果存储]
        K --> L[报表生成]
    end
    
    style D fill:#c8e6c9,stroke:#2e7d32
    style J fill:#fff3e0,stroke:#e65100
</div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 实时预测：单个用户流失概率</span>
<span class="kwd">SELECT</span> 
    customer_id,
    age,
    income,
    <span class="func">PREDICT</span>(customer_churn_model <span class="kwd">USING</span> 
        age = <span class="num">35</span>,
        income = <span class="num">50000</span>,
        purchase_frequency = <span class="num">12</span>,
        avg_order_value = <span class="num">150.00</span>,
        days_since_last_purchase = <span class="num">15</span>,
        total_orders = <span class="num">50</span>,
        avg_review_score = <span class="num">4.5</span>
    ) <span class="kwd">as</span> churn_probability;

<span class="com">-- 批量预测：对所有未标记用户进行预测</span>
<span class="kwd">SELECT</span> 
    customer_id,
    <span class="func">PREDICT</span>(customer_churn_model <span class="kwd">USING</span> 
        age, income, purchase_frequency, avg_order_value, 
        days_since_last_purchase, total_orders, avg_review_score
    ) <span class="kwd">as</span> churn_probability,
    <span class="kwd">CASE</span>
        WHEN <span class="func">PREDICT</span>(customer_churn_model <span class="kwd">USING</span> 
            age, income, purchase_frequency, avg_order_value, 
            days_since_last_purchase, total_orders, avg_review_score) > <span class="num">0.7</span> 
        THEN <span class="str">'高风险'</span>
        WHEN <span class="func">PREDICT</span>(customer_churn_model <span class="kwd">USING</span> 
            age, income, purchase_frequency, avg_order_value, 
            days_since_last_purchase, total_orders, avg_review_score) > <span class="num">0.3</span> 
        THEN <span class="str">'中风险'</span>
        <span class="kwd">ELSE</span> <span class="str">'低风险'</span>
    <span class="kwd">END</span> <span class="kwd">as</span> risk_level
<span class="kwd">FROM</span> customer_features
<span class="kwd">WHERE</span> churn_label <span class="kwd">IS</span> NULL;

<span class="com">-- 创建预测结果表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> churn_predictions (
    customer_id <span class="kwd">INT PRIMARY KEY</span>,
    predicted_churn_probability <span class="kwd">DECIMAL</span>(<span class="num">5</span>,<span class="num">4</span>),
    risk_level <span class="type">VARCHAR</span>(<span class="num">20</span>),
    predicted_at <span class="type">TIMESTAMP</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>,
    <span class="kwd">FOREIGN KEY</span> (customer_id) <span class="kwd">REFERENCES</span> customer_features(customer_id)
);

<span class="com">-- 批量预测并存储结果</span>
INSERT <span class="kwd">INTO</span> churn_predictions (customer_id, predicted_churn_probability, risk_level)
<span class="kwd">SELECT</span> 
    customer_id,
    <span class="func">PREDICT</span>(customer_churn_model <span class="kwd">USING</span> 
        age, income, purchase_frequency, avg_order_value, 
        days_since_last_purchase, total_orders, avg_review_score
    ) <span class="kwd">as</span> prob,
    <span class="kwd">CASE</span>
        WHEN prob > <span class="num">0.7</span> THEN <span class="str">'高风险'</span>
        WHEN prob > <span class="num">0.3</span> THEN <span class="str">'中风险'</span>
        <span class="kwd">ELSE</span> <span class="str">'低风险'</span>
    <span class="kwd">END</span>
<span class="kwd">FROM</span> customer_features
<span class="kwd">WHERE</span> churn_label <span class="kwd">IS</span> NULL;</code></pre>
                </div>
                
                <h4>2.3 模型评估与优化</h4>
                <p>MySQL 提供了丰富的模型评估指标，帮助您了解模型性能并进行针对性优化。</p>
                
                <div class="comparison-table">
                    <table>
                        <thead>
                            <tr>
                                <th>指标</th>
                                <th>说明</th>
                                <th>适用场景</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>Accuracy</td>
                                <td>准确率 - 正确预测的比例</td>
                                <td>数据平衡的分类问题</td>
                            </tr>
                            <tr>
                                <td>Precision</td>
                                <td>精确率 - 预测为正的样本中实际为正的比例</td>
                                <td>误报代价高的场景</td>
                            </tr>
                            <tr>
                                <td>Recall</td>
                                <td>召回率 - 实际为正的样本中被正确预测的比例</td>
                                <td>漏报代价高的场景</td>
                            </tr>
                            <tr>
                                <td>F1-Score</td>
                                <td>精确率和召回率的调和平均</td>
                                <td>数据不平衡的分类问题</td>
                            </tr>
                            <tr>
                                <td>AUC-ROC</td>
                                <td>ROC曲线下面积，衡量分类器区分能力</td>
                                <td>二分类问题的通用评估</td>
                            </tr>
                            <tr>
                                <td>MSE/RMSE</td>
                                <td>均方误差/均方根误差</td>
                                <td>回归问题</td>
                            </tr>
                            <tr>
                                <td>MAE</td>
                                <td>平均绝对误差</td>
                                <td>回归问题，对异常值不敏感</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 查看模型评估指标</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.ml_model_evaluation
<span class="kwd">WHERE</span> model_name = <span class="str">'customer_churn_model'</span>;

<span class="com">-- 模型评估结果示例输出：</span>
<span class="com">-- +------------------+-------------+-------------+------------+</span>
<span class="com">-- | metric           | value       | train_score | test_score |</span>
<span class="com">-- +------------------+-------------+-------------+------------+</span>
<span class="com">-- | accuracy         | 0.9234      | 0.9567      | 0.9234     |</span>
<span class="com">-- | precision        | 0.8912      | 0.9456      | 0.8912     |</span>
<span class="com">-- | recall           | 0.8678      | 0.9234      | 0.8678     |</span>
<span class="com">-- | f1_score         | 0.8793      | 0.9344      | 0.8793     |</span>
<span class="com">-- | auc_roc          | 0.9456      | 0.9876      | 0.9456     |</span>
<span class="com">-- +------------------+-------------+-------------+------------+</span>

<span class="com">-- 查看混淆矩阵</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.ml_confusion_matrix
<span class="kwd">WHERE</span> model_name = <span class="str">'customer_churn_model'</span>;

<span class="com">-- 查看特征重要性</span>
<span class="kwd">SELECT</span> feature_name, importance_score
<span class="kwd">FROM</span> sys.ml_feature_importance
<span class="kwd">WHERE</span> model_name = <span class="str">'customer_churn_model'</span>
<span class="kwd">ORDER BY</span> importance_score DESC;

<span class="com">-- 特征重要性示例：</span>
<span class="com">-- +-----------------------------+------------------+</span>
<span class="com">-- | feature_name                | importance_score |</span>
<span class="com">-- +-----------------------------+------------------+</span>
<span class="com">-- | days_since_last_purchase   | 0.3245          |</span>
<span class="com">-- | purchase_frequency         | 0.2876          |</span>
<span class="com">-- | avg_order_value            | 0.1987          |</span>
<span class="com">-- | total_orders               | 0.1234          |</span>
<span class="com">-- | age                        | 0.0456          |</span>
<span class="com">-- | income                     | 0.0202          |</span>
<span class="com">-- +-----------------------------+------------------+</span>

<span class="com">-- 超参数调优</span>
<span class="kwd">CREATE</span> ML <span class="kwd">MODEL</span> customer_churn_tuned
<span class="kwd">FROM</span> customer_features
FEATURES (age, income, purchase_frequency, avg_order_value, days_since_last_purchase, total_orders)
TARGET (churn_label)
ALGORITHM <span class="str">'gradient_boosting'</span>
OPTIONS (
    n_estimators = <span class="num">200</span>,
    max_depth = <span class="num">7</span>,
    learning_rate = <span class="num">0.05</span>,
    min_samples_split = <span class="num">10</span>,
    min_samples_leaf = <span class="num">5</span>,
    subsample = <span class="num">0.8</span>,
    colsample_bytree = <span class="num">0.8</span>,
    grid_search = TRUE,    <span class="com">-- 启用网格搜索调优</span>
    cv_folds = <span class="num">5</span>          <span class="com">-- 5折交叉验证</span>
);</code></pre>
                </div>
                
                <h4>2.4 实际应用案例</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 案例1：电商用户流失预警系统</span>
<span class="com">-- 创建用户行为特征表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> user_behavior_features (
    user_id <span class="kwd">INT PRIMARY KEY</span>,
    registration_date <span class="type">DATE</span>,
    last_login_date <span class="type">DATE</span>,
    total_login_days <span class="kwd">INT</span>,
    avg_session_duration <span class="kwd">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>),
    browse_count <span class="kwd">INT</span>,
    cart_add_count <span class="kwd">INT</span>,
    purchase_count <span class="kwd">INT</span>,
    wishlist_count <span class="kwd">INT</span>,
    review_count <span class="kwd">INT</span>,
    avg_rating_given <span class="kwd">DECIMAL</span>(<span class="num">3</span>,<span class="num">2</span>),
    coupon_usage_count <span class="kwd">INT</span>,
    referral_count <span class="kwd">INT</span>,
    support_ticket_count <span class="kwd">INT</span>,
    is_churned <span class="kwd">TINYINT</span>  <span class="com">-- 目标变量：1=流失</span>
);

<span class="com">-- 训练流失预测模型</span>
<span class="kwd">CREATE</span> ML <span class="kwd">MODEL</span> churn_prediction_model
<span class="kwd">FROM</span> user_behavior_features
FEATURES (
    DATEDIFF(NOW(), registration_date),
    DATEDIFF(NOW(), last_login_date),
    total_login_days,
    avg_session_duration,
    browse_count,
    cart_add_count,
    purchase_count,
    wishlist_count,
    review_count,
    avg_rating_given,
    coupon_usage_count,
    referral_count,
    support_ticket_count
)
TARGET (is_churned)
ALGORITHM <span class="str">'random_forest'</span>
OPTIONS (n_estimators = <span class="num">150</span>, max_depth = <span class="num">10</span>);

<span class="com">-- 实时预测高风险用户</span>
<span class="kwd">SELECT</span> 
    user_id,
    <span class="func">PREDICT</span>(churn_prediction_model <span class="kwd">USING</span>
        DATEDIFF(NOW(), registration_date) = <span class="num">90</span>,
        DATEDIFF(NOW(), last_login_date) = <span class="num">15</span>,
        total_login_days = <span class="num">25</span>,
        avg_session_duration = <span class="num">1800</span>,
        browse_count = <span class="num">50</span>,
        cart_add_count = <span class="num">10</span>,
        purchase_count = <span class="num">3</span>,
        wishlist_count = <span class="num">8</span>,
        review_count = <span class="num">2</span>,
        avg_rating_given = <span class="num">4.5</span>,
 = <span class="num">5        coupon_usage_count</span>,
        referral_count = <span class="num">1</span>,
        support_ticket_count = <span class="num">0</span>
    ) <span class="kwd">as</span> churn_risk
<span class="kwd">FROM</span> user_behavior_features
<span class="kwd">WHERE</span> is_churned <span class="kwd">IS</span> NULL
<span class="kwd">ORDER BY</span> churn_risk DESC
<span class="kwd">LIMIT</span> <span class="num">100</span>;</code></pre>
                </div>
                
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 案例2：商品销量预测</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> sales_data (
    product_id <span class="kwd">INT</span>,
    date <span class="type">DATE</span>,
    unit_price <span class="kwd">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>),
    discount_rate <span class="kwd">DECIMAL</span>(<span class="num">5</span>,<span class="num">4</span>),
    advertising_budget <span class="kwd">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>),
    competitor_price <span class="kwd">DECIMAL</span>(<span class="num">10</span>,<span class="num">2</span>),
    holiday_flag <span class="kwd">TINYINT</span>,
    season <span class="type">VARCHAR</span>(<span class="num">20</span>),
    quantity_sold <span class="kwd">INT</span>
);

<span class="com">-- 训练销量预测模型</span>
<span class="kwd">CREATE</span> ML <span class="kwd">MODEL</span> sales_forecast_model
<span class="kwd">FROM</span> sales_data
FEATURES (unit_price, discount_rate, advertising_budget, competitor_price, holiday_flag)
TARGET (quantity_sold)
ALGORITHM <span class="str">'linear_regression'</span>;

<span class="com">-- 预测未来销量</span>
<span class="kwd">SELECT</span> 
    product_id,
    <span class="func">PREDICT</span>(sales_forecast_model <span class="kwd">USING</span>
        unit_price = <span class="num">99.00</span>,
        discount_rate = <span class="num">0.15</span>,
        advertising_budget = <span class="num">5000</span>,
        competitor_price = <span class="num">109.00</span>,
        holiday_flag = <span class="num">1</span>
    ) <span class="kwd">as</span> predicted_sales
<span class="kwd">FROM</span> sales_data
<span class="kwd">GROUP BY</span> product_id
<span class="kwd">ORDER BY</span> predicted_sales DESC;</code></pre>
                </div>
                
                <h4>2.5 模型管理</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 查看所有模型</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.ml_models;

<span class="com">-- 模型列表输出示例：</span>
<span class="com">-- +---------------------------+----------------+----------------+----------------+</span>
<span class="com">-- | model_name                | algorithm      | created_at     | status         |</span>
<span class="com">-- +---------------------------+----------------+----------------+----------------+</span>
<span class="com">-- | customer_churn_model      | gradient_boost | 2024-01-15    | ready          |</span>
<span class="com">-- | sales_forecast_model      | linear_reg     | 2024-01-20    | ready          |</span>
<span class="com">-- | user_clustering_model     | kmeans         | 2024-01-25    | training       |</span>
<span class="com">-- +---------------------------+----------------+----------------+----------------+</span>

<span class="com">-- 查看模型详细信息</span>
<span class="kwd">DESCRIBE</span> ML <span class="kwd">MODEL</span> customer_churn_model;

<span class="com">-- 模型版本管理</span>
<span class="kwd">ALTER</span> ML <span class="kwd">MODEL</span> customer_churn_model
RETRAIN <span class="kwd">FROM</span> customer_features
FEATURES (age, income, purchase_frequency, avg_order_value, days_since_last_purchase)
TARGET (churn_label);

<span class="com">-- 回滚到之前的版本</span>
<span class="kwd">ALTER</span> ML <span class="kwd">MODEL</span> customer_churn_model
VERSION TO <span class="str">'v1'</span>;

<span class="com">-- 导出模型用于部署</span>
<span class="kwd">EXPORT</span> ML <span class="kwd">MODEL</span> customer_churn_model
<span class="kwd">TO</span> <span class="str">'/backup/models/'</span>
FORMAT <span class="str">'onnx'</span>;

<span class="com">-- 导入外部训练的模型</span>
<span class="kwd">IMPORT</span> ML <span class="kwd">MODEL</span> customer_churn_model_v2
<span class="kwd">FROM</span> <span class="str">'/backup/models/external_model.onnx'</span>;

<span class="com">-- 删除模型</span>
<span class="kwd">DROP</span> ML <span class="kwd">MODEL</span> customer_churn_model;

<span class="com">-- 模型权限管理</span>
<span class="kwd">GRANT</span> ML <span class="kwd">MODEL</span> <span class="str">'customer_churn_model'</span> <span class="kwd">TO</span> <span class="str">'data scientist'</span>@<span class="str">'%'</span>;
<span class="kwd">REVOKE</span> ML <span class="kwd">MODEL</span> <span class="str">'customer_churn_model'</span> <span class="kwd">FROM</span> <span class="str">'readonly_user'</span>@<span class="str">'%'</span>;</code></pre>
                </div>
                
                <h4>2.6 常见问题和最佳实践</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 最佳实践1：数据质量保证</span>
<span class="com">-- 检查缺失值</span>
<span class="kwd">SELECT</span> 
    <span class="func">COUNT</span>(*) <span class="kwd">as</span> total_rows,
    <span class="func">SUM</span>(CASE <span class="kwd">WHEN</span> age <span class="kwd">IS</span> NULL THEN <span class="num">1</span> <span class="kwd">ELSE</span> <span class="num">0</span> <span class="kwd">END</span>) <span class="kwd">as</span> missing_age,
    <span class="func">SUM</span>(CASE <span class="kwd">WHEN</span> income <span class="kwd">IS</span> NULL THEN <span class="num">1</span> <span class="kwd">ELSE</span> <span class="num">0</span> <span class="kwd">END</span>) <span class="kwd">as</span> missing_income
<span class="kwd">FROM</span> customer_features;

<span class="com">-- 处理缺失值：填充默认值</span>
<span class="kwd">CREATE</span> <span class="kwd">VIEW</span> customer_features_clean <span class="kwd">AS</span>
<span class="kwd">SELECT</span>
    customer_id,
    <span class="func">COALESCE</span>(age, <span class="func">AVG</span>(age) OVER()) <span class="kwd">as</span> age,
    <span class="func">COALESCE</span>(income, <span class="func">MEDIAN</span>(income) OVER()) <span class="kwd">as</span> income
<span class="kwd">FROM</span> customer_features;

<span class="com">-- 最佳实践2：特征标准化</span>
<span class="com">-- 标准化数值特征</span>
<span class="kwd">CREATE</span> <span class="kwd">VIEW</span> customer_features_scaled <span class="kwd">AS</span>
<span class="kwd">SELECT</span>
    customer_id,
    (age - <span class="func">AVG</span>(age) OVER()) / <span class="func">STDDEV</span>(age) OVER() <span class="kwd">as</span> age_scaled,
    (income - <span class="func">AVG</span>(income) OVER()) / <span class="func">STDDEV</span>(income) OVER() <span class="kwd">as</span> income_scaled
<span class="kwd">FROM</span> customer_features;

<span class="com">-- 最佳实践3：防止过拟合</span>
<span class="com">-- 使用交叉验证和早停</span>
<span class="kwd">CREATE</span> ML <span class="kwd">MODEL</span> customer_churn_balanced
<span class="kwd">FROM</span> customer_features
FEATURES (age, income, purchase_frequency, avg_order_value)
TARGET (churn_label)
ALGORITHM <span class="str">'gradient_boosting'</span>
OPTIONS (
    n_estimators = <span class="num">100</span>,
    early_stopping_rounds = <span class="num">10</span>,  <span class="com">-- 早停</span>
    validation_fraction = <span class="num">0.1</span>,    <span class="com">-- 验证集比例</span>
    n_iter_no_change = <span class="num">5</span>          <span class="com">-- 连续5次不改善则停止</span>
);

<span class="com">-- 最佳实践4：模型监控</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> model_performance_log (
    model_name <span class="type">VARCHAR</span>(<span class="num">100</span>),
    evaluation_date <span class="type">DATE</span>,
    accuracy <span class="kwd">DECIMAL</span>(<span class="num">5</span>,<span class="num">4</span>),
    precision_score <span class="kwd">DECIMAL</span>(<span class="num">5</span>,<span class="num">4</span>),
    recall <span class="kwd">DECIMAL</span>(<span class="num">5</span>,<span class="num">4</span>),
    f1_score <span class="kwd">DECIMAL</span>(<span class="num">5</span>,<span class="num">4</span>),
    sample_size <span class="kwd">INT</span>
);

<span class="com">-- 定期记录模型性能</span>
INSERT <span class="kwd">INTO</span> model_performance_log
<span class="kwd">SELECT</span> 
    <span class="str">'customer_churn_model'</span>,
    <span class="func">CURDATE</span>(),
    accuracy,
    precision,
    recall,
    f1_score,
    sample_size
<span class="kwd">FROM</span> sys.ml_model_evaluation
<span class="kwd">WHERE</span> model_name = <span class="str">'customer_churn_model'</span>;</code></pre>
                </div>
                </details>

                <h3>3. 向量搜索与语义查询</h3>
                
                <h4>3.1 向量索引</h4>
                <p>MySQL 9.x 原生支持向量数据类型和向量索引，可用于语义搜索、相似度匹配等 AI 应用场景。</p>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 创建包含向量列的表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> documents (
    id <span class="kwd">INT PRIMARY KEY</span>,
    title <span class="type">VARCHAR</span>(<span class="num">255</span>),
    content <span class="type">TEXT</span>,
    embedding <span class="type">VECTOR</span>(<span class="num">768</span>),  <span class="com">-- 768维向量（支持 BERT 等模型）</span>
    <span class="kwd">INDEX</span> idx_embedding (embedding) <span class="kwd">USING</span> HNSW
);

<span class="com">-- 插入带向量的数据</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> documents (id, title, content, embedding)
<span class="kwd">VALUES</span> (
    <span class="num">1</span>, 
    <span class="str">'MySQL 教程'</span>, 
    <span class="str">'MySQL 是一种关系型数据库管理系统...'</span>,
    <span class="str">'[0.12, -0.34, 0.56, ...]'</span>  <span class="com">-- 实际使用 embedding 生成工具</span>
);

<span class="com">-- 创建向量索引（HNSW 算法）</span>
<span class="kwd">ALTER</span> <span class="kwd">TABLE</span> documents 
ADD <span class="kwd">INDEX</span> idx_vector (embedding) <span class="kwd">USING</span> HNSW
OPTIONS (m = <span class="num">16</span>, ef_construction = <span class="num">200</span>);</code></pre>
                </div>

                <h4>3.2 向量相似度搜索</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 向量距离计算函数：</span>
<span class="com">-- VECTOR_DISTANCE(v1, v2, 'cosine') - 余弦相似度</span>
<span class="com">-- VECTOR_DISTANCE(v1, v2, 'euclidean') - 欧氏距离</span>
<span class="com">-- VECTOR_DISTANCE(v1, v2, 'dot_product') - 点积</span>

<span class="com">-- 查找最相似的文档</span>
<span class="kwd">SELECT</span> id, title, 
    <span class="func">VECTOR_DISTANCE</span>(embedding, <span class="str">'[0.12, -0.34, 0.56, ...]'</span>, <span class="str">'cosine'</span>) <span class="kwd">as</span> distance
<span class="kwd">FROM</span> documents
<span class="kwd">ORDER BY</span> distance
<span class="kwd">LIMIT</span> <span class="num">5</span>;

<span class="com">-- 使用向量索引加速搜索（近似最近邻）</span>
<span class="kwd">SELECT</span> id, title,
    <span class="func">VECTOR_DISTANCE</span>(embedding, <span class="str">'[query_vector]'</span>, <span class="str">'cosine'</span>) <span class="kwd">as</span> distance
<span class="kwd">FROM</span> documents
<span class="kwd">ORDER BY</span> distance
<span class="kwd">LIMIT</span> <span class="num">10</span>;

<span class="com">-- 过滤条件 + 向量搜索</span>
<span class="kwd">SELECT</span> id, title
<span class="kwd">FROM</span> documents
<span class="kwd">WHERE</span> category = <span class="str">'数据库'</span>
<span class="kwd">ORDER BY</span> <span class="func">VECTOR_DISTANCE</span>(embedding, <span class="str">'[query_vector]'</span>, <span class="str">'cosine'</span>)
<span class="kwd">LIMIT</span> <span class="num">5</span>;</code></pre>
                </div>

                <h3>4. 自然语言查询</h3>
                
                <h4>4.1 NL2SQL 转换</h4>
                <p>通过自然语言处理技术，将自然语言查询转换为优化的 SQL 语句。</p>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 使用自然语言查询</span>
<span class="kwd">CALL</span> sys.natural_language_query(
    <span class="str">'查找2024年销售额超过10000元的客户'</span>
);

<span class="com">-- AI 生成的 SQL 示例：</span>
<span class="com">-- SELECT c.name, SUM(o.total_amount) as total_sales</span>
<span class="com">-- FROM customers c</span>
<span class="com">-- JOIN orders o ON c.id = o.customer_id</span>
<span class="com">-- WHERE YEAR(o.order_date) = 2024</span>
<span class="com">-- GROUP BY c.id, c.name</span>
<span class="com">-- HAVING SUM(o.total_amount) > 10000</span>

<span class="com">-- 自然语言查询复杂问题</span>
<span class="kwd">SELECT</span> <span class="func">NL</span>(<span class="str">'哪些产品的月销量呈下降趋势？'</span>);

<span class="com">-- 查看历史自然语言查询</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.nl_query_history
<span class="kwd">ORDER BY</span> query_time DESC
<span class="kwd">LIMIT</span> <span class="num">20</span>;</code></pre>
                </div>

                <h4>4.2 查询解释与优化建议</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- AI 解释查询意图</span>
<span class="kwd">SELECT</span> sys.explain_query(
    <span class="str">'SELECT * FROM orders WHERE status = "pending"'</span>
) <span class="kwd">as</span> explanation;

<span class="com">-- 获取性能优化建议</span>
<span class="kwd">SELECT</span> sys.get_optimization_suggestions(
    <span class="str">'SELECT o.*, c.name FROM orders o JOIN customers c ON o.customer_id = c.id'</span>
);

<span class="com">-- SQL 语句改写建议</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.query_rewrites
<span class="kwd">WHERE</span> original_query LIKE <span class="str">'%orders%'</span>;</code></pre>
                </div>

                <h3>5. 智能异常检测</h3>
                
                <h4>5.1 数据异常检测</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 配置异常检测</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> anomaly_detection_config (
    table_name <span class="type">VARCHAR</span>(<span class="num">64</span>),
    column_name <span class="type">VARCHAR</span>(<span class="num">64</span>),
    detection_method <span class="type">VARCHAR</span>(<span class="num">20</span>),  <span class="com">-- 'statistical', 'ml', 'isolation_forest'</span>
    sensitivity <span class="kwd">DECIMAL</span>(<span class="num">3</span>,<span class="num">2</span>)  <span class="com">-- 0.0-1.0</span>
);

<span class="com">-- 为用户表启用异常检测</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> anomaly_detection_config
<span class="kwd">VALUES</span> (<span class="str">'users'</span>, <span class="str">'age'</span>, <span class="str">'isolation_forest'</span>, <span class="num">0.8</span>);

<span class="com">-- 手动触发异常检测</span>
<span class="kwd">CALL</span> sys.detect_data_anomalies(<span class="str">'users'</span>);

<span class="com">-- 查看检测到的异常</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.detected_anomalies
<span class="kwd">WHERE</span> table_name = <span class="str">'users'</span>
<span class="kwd">AND</span> detected_at > <span class="func">NOW</span>() - INTERVAL <span class="num">1</span> DAY;</code></pre>
                </div>

                <h4>5.2 性能异常检测</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 启用性能异常检测</span>
<span class="kwd">SET</span> GLOBAL performance_anomaly_detection = <span class="str">'ON'</span>;

<span class="com">-- 配置性能指标阈值</span>
<span class="kwd">CREATE</span> <span class="kwd">EVENT</span> hourly_performance_check
<span class="kwd">ON</span> <span class="kwd">SCHEDULE</span> <span class="kwd">EVERY</span> <span class="num">1</span> <span class="kwd">HOUR</span>
DO
<span class="kwd">BEGIN</span>
    <span class="kwd">CALL</span> sys.detect_performance_anomalies();
    <span class="kwd">CALL</span> sys.detect_slow_queries();
<span class="kwd">END</span>;

<span class="com">-- 查看性能异常</span>
<span class="kwd">SELECT</span> 
    <span class="kwd">timestamp</span>,
    metric_name,
    expected_value,
    actual_value,
    anomaly_score
<span class="kwd">FROM</span> sys.performance_anomalies
<span class="kwd">WHERE</span> <span class="kwd">timestamp</span> > <span class="func">NOW</span>() - INTERVAL <span class="num">24</span> HOURS
<span class="kwd">ORDER BY</span> anomaly_score DESC;

<span class="com">-- 异常自动告警</span>
<span class="kwd">CREATE</span> <span class="kwd">TRIGGER</span> performance_anomaly_alert
<span class="kwd">AFTER</span> <span class="kwd">INSERT</span> <span class="kwd">ON</span> sys.performance_anomalies
<span class="kwd">FOR</span> <span class="kwd">EACH</span> <span class="kwd">ROW</span>
<span class="kwd">BEGIN</span>
    <span class="kwd">IF</span> NEW.anomaly_score > <span class="num">0.9</span> <span class="kwd">THEN</span>
        <span class="kwd">INSERT</span> <span class="kwd">INTO</span> alert_log <span class="kwd">VALUES</span>(NEW.<span class="kwd">timestamp</span>, NEW.metric_name);
    <span class="kwd">END</span> <span class="kwd">IF</span>;
<span class="kwd">END</span>;</code></pre>
                </div>

                <h3>6. 智能索引推荐</h3>
                
                <h4>6.1 自动索引分析</h4>
                <div class="code-block">
                    <pre><span class="com">-- 开启查询分析收集</span>
<span class="kwd">SET</span> GLOBAL optimizer_trace = <span class="str">'enabled=on'</span>;
<span class="kwd">SET</span> GLOBAL performance_schema = <span class="str">'ON'</span>;

<span class="com">-- 运行一段时间后，分析查询模式</span>
<span class="kwd">CALL</span> sys.analyze_workload(<span class="str">'your_database'</span>);

<span class="com">-- 查看索引推荐</span>
<span class="kwd">SELECT</span> 
    table_name,
    suggested_index,
    columns,
    potential_improvement,
    estimated_size
<span class="kwd">FROM</span> sys.index_recommendations
<span class="kwd">WHERE</span> table_schema = <span class="str">'your_database'</span>
<span class="kwd">ORDER BY</span> potential_improvement DESC;</code></pre>
                </div>

                <h4>6.2 自动应用索引</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 预览索引创建语句</span>
<span class="kwd">SELECT</span> create_index_statement
<span class="kwd">FROM</span> sys.index_recommendations
<span class="kwd">WHERE</span> table_name = <span class="str">'orders'</span>
<span class="kwd">AND</span> recommended_index = <span class="str">'idx_customer_date'</span>;

<span class="com">-- 手动应用推荐索引</span>
<span class="kwd">CALL</span> sys.apply_index_recommendation(
    <span class="str">'orders'</span>, 
    <span class="str">'idx_customer_date'</span>
);

<span class="com">-- 自动应用安全索引（可快速回滚）</span>
<span class="kwd">CALL</span> sys.apply_recommended_indexes(
    <span class="str">'your_database'</span>,
    <span class="str">'auto'</span>,
    <span class="num">1000</span>  <span class="com">-- 最大影响行数阈值</span>
);

<span class="com">-- 回滚索引变更</span>
<span class="kwd">CALL</span> sys.rollback_index_change(<span class="str">'idx_customer_date'</span>, <span class="str">'orders'</span>);</code></pre>
                </div>

                <h3>7. AI 辅助运维</h3>
                
                <h4>7.1 智能监控仪表盘</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 查看 AI 健康状态报告</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.ai_health_check\G

<span class="com">-- AI 生成的优化建议</span>
<span class="kwd">SELECT</span> 
    category,
    issue,
    recommendation,
    priority,
    estimated_impact
<span class="kwd">FROM</span> sys.ai_recommendations
<span class="kwd">WHERE</span> status = <span class="str">'pending'</span>
<span class="kwd">ORDER BY</span> priority DESC;

<span class="com">-- 自动性能调优</span>
<span class="kwd">CALL</span> sys.auto_tune(<span class="str">'your_database'</span>);

<span class="com">-- 查看调优历史</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.auto_tune_history
<span class="kwd">WHERE</span> tuned_at > <span class="func">NOW</span>() - INTERVAL <span class="num">7</span> DAY;</code></pre>
                </div>

                <h4>7.2 容量预测</h4>
                <div class="code-block">
                    <pre><code class="sql"><span class="com">-- 存储容量预测</span>
<span class="kwd">SELECT</span> 
    table_name,
    current_size_mb,
    predicted_size_30d,
    predicted_size_90d,
    days_until_full
<span class="kwd">FROM</span> sys.capacity_predictions
<span class="kwd">WHERE</span> table_schema = <span class="str">'your_database'</span>;

<span class="com">-- 性能趋势预测</span>
<span class="kwd">SELECT</span> 
    metric_name,
    current_value,
    predicted_value_7d,
    trend
<span class="kwd">FROM</span> sys.performance_predictions;

<span class="com">-- 基于预测自动扩容建议</span>
<span class="kwd">SELECT</span> * <span class="kwd">FROM</span> sys.scaling_recommendations
<span class="kwd">WHERE</span> recommendation_type = <span class="str">'storage'</span>;</code></pre>
                </div>
            </div>
        </section>

        <section id="practice" class="section">
            <h2>实战练习</h2>
            <div class="content">
                <div class="practice-project">
                    <h3>项目一：博客管理系统</h3>
                    <p>构建一个简单的博客管理系统，包含用户、文章、评论等功能。</p>

                    <details>
                        <summary>查看完整代码</summary>
                        <div class="code-block">
                            <pre><code class="sql"><span class="com">-- 创建数据库</span>
<span class="kwd">CREATE</span> <span class="kwd">DATABASE</span> blog_system;
<span class="kwd">USE</span> blog_system;

<span class="com">-- 用户表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> users (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    username <span class="type">VARCHAR</span>(<span class="num">50</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span> <span class="kwd">UNIQUE</span>,
    <span class="kwd">password</span> <span class="type">VARCHAR</span>(<span class="num">255</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    email <span class="type">VARCHAR</span>(<span class="num">100</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span> <span class="kwd">UNIQUE</span>,
    created_at <span class="kwd">TIMESTAMP</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>
);

<span class="com">-- 分类表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> categories (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    name <span class="type">VARCHAR</span>(<span class="num">50</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    description <span class="kwd">TEXT</span>
);

<span class="com">-- 文章表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> posts (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    title <span class="type">VARCHAR</span>(<span class="num">200</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    content <span class="kwd">TEXT</span> <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    author_id <span class="kwd">INT</span> <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    category_id <span class="type">INT</span>,
    views <span class="kwd">INT</span> <span class="kwd">DEFAULT</span> <span class="num">0</span>,
    <span class="kwd">status</span> <span class="type">ENUM</span>(<span class="str">'draft'</span>, <span class="str">'published'</span>, <span class="str">'archived'</span>) <span class="kwd">DEFAULT</span> <span class="str">'draft'</span>,
    created_at <span class="kwd">TIMESTAMP</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>,
    updated_at <span class="kwd">TIMESTAMP</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span> <span class="kwd">ON</span> <span class="kwd">UPDATE</span> <span class="kwd">CURRENT_TIMESTAMP</span>,
    <span class="kwd">FOREIGN KEY</span> (author_id) <span class="kwd">REFERENCES</span> users(id) <span class="kwd">ON</span> <span class="kwd">DELETE</span> <span class="kwd">CASCADE</span>,
    <span class="kwd">FOREIGN KEY</span> (category_id) <span class="kwd">REFERENCES</span> categories(id) <span class="kwd">ON</span> <span class="kwd">DELETE</span> <span class="kwd">SET</span> <span class="kwd">NULL</span>
);

<span class="com">-- 评论表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> comments (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    post_id <span class="kwd">INT</span> <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    user_id <span class="kwd">INT</span> <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    content <span class="kwd">TEXT</span> <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    created_at <span class="kwd">TIMESTAMP</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>,
    <span class="kwd">FOREIGN KEY</span> (post_id) <span class="kwd">REFERENCES</span> posts(id) <span class="kwd">ON</span> <span class="kwd">DELETE</span> <span class="kwd">CASCADE</span>,
    <span class="kwd">FOREIGN KEY</span> (user_id) <span class="kwd">REFERENCES</span> users(id) <span class="kwd">ON</span> <span class="kwd">DELETE</span> <span class="kwd">CASCADE</span>
);

<span class="com">-- 插入示例数据</span>
<span class="kwd">INSERT</span> <span class="kwd">INTO</span> categories (name, description) <span class="kwd">VALUES</span>
    (<span class="str">'技术'</span>, <span class="str">'技术相关文章'</span>),
    (<span class="str">'生活'</span>, <span class="str">'生活分享'</span>),
    (<span class="str">'学习'</span>, <span class="str">'学习笔记'</span>);

<span class="kwd">INSERT</span> <span class="kwd">INTO</span> users (username, <span class="kwd">password</span>, email) <span class="kwd">VALUES</span>
    (<span class="str">'admin'</span>, <span class="str">'hashed_password'</span>, <span class="str">'admin@example.com'</span>),
    (<span class="str">'zhangsan'</span>, <span class="str">'hashed_password'</span>, <span class="str">'zhangsan@example.com'</span>);

<span class="kwd">INSERT</span> <span class="kwd">INTO</span> posts (title, content, author_id, category_id, <span class="kwd">status</span>) <span class="kwd">VALUES</span>
    (<span class="str">'MySQL 入门教程'</span>, <span class="str">'这是 MySQL 入门教程的内容...'</span>, <span class="num">1</span>, <span class="num">1</span>, <span class="str">'published'</span>),
    (<span class="str">'学习笔记'</span>, <span class="str">'今天学习了数据库基础知识'</span>, <span class="num">2</span>, <span class="num">3</span>, <span class="str">'published'</span>);

<span class="kwd">INSERT</span> <span class="kwd">INTO</span> comments (post_id, user_id, content) <span class="kwd">VALUES</span>
    (<span class="num">1</span>, <span class="num">2</span>, <span class="str">'很好的教程，学到了很多！'</span>),
    (<span class="num">2</span>, <span class="num">1</span>, <span class="str">'继续加油！'</span>);</code></pre>
                                </div>
                    </details>
                </div>

                <div class="practice-project">
                    <h3>项目二：电商订单系统</h3>
                    <p>设计一个电商订单系统，包含商品、订单、订单详情等表。</p>

                    <details>
                        <summary>查看完整代码</summary>
                        <div class="code-block">
                            <pre><code class="sql"><span class="com">-- 创建数据库</span>
<span class="kwd">CREATE</span> <span class="kwd">DATABASE</span> ecommerce;
<span class="kwd">USE</span> ecommerce;

<span class="com">-- 商品表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> products (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    name <span class="type">VARCHAR</span>(<span class="num">200</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    description <span class="type">TEXT</span>,
    price <span class="type">DECIMAL</span>(<span class="num">10</span>, <span class="num">2</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    stock <span class="kwd">INT</span> <span class="kwd">DEFAULT</span> <span class="num">0</span>,
    category <span class="type">VARCHAR</span>(<span class="num">50</span>),
    created_at <span class="kwd">TIMESTAMP</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>
);

<span class="com">-- 用户表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> customers (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    username <span class="type">VARCHAR</span>(<span class="num">50</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span> <span class="kwd">UNIQUE</span>,
    email <span class="type">VARCHAR</span>(<span class="num">100</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span> <span class="kwd">UNIQUE</span>,
    phone <span class="type">VARCHAR</span>(<span class="num">20</span>),
    address <span class="type">TEXT</span>,
    created_at <span class="kwd">TIMESTAMP</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>
);

<span class="com">-- 订单表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> orders (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    customer_id <span class="kwd">INT</span> <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    total_amount <span class="type">DECIMAL</span>(<span class="num">10</span>, <span class="num">2</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    <span class="kwd">status</span> <span class="type">ENUM</span>(<span class="str">'pending'</span>, <span class="str">'confirmed'</span>, <span class="str">'shipped'</span>, <span class="str">'delivered'</span>, <span class="str">'cancelled'</span>) <span class="kwd">DEFAULT</span> <span class="str">'pending'</span>,
    order_date <span class="kwd">TIMESTAMP</span> <span class="kwd">DEFAULT</span> <span class="kwd">CURRENT_TIMESTAMP</span>,
    <span class="kwd">FOREIGN KEY</span> (customer_id) <span class="kwd">REFERENCES</span> customers(id)
);

<span class="com">-- 订单详情表</span>
<span class="kwd">CREATE</span> <span class="kwd">TABLE</span> order_items (
    id <span class="kwd">INT</span> <span class="kwd">AUTO_INCREMENT</span> <span class="kwd">PRIMARY KEY</span>,
    order_id <span class="kwd">INT</span> <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    product_id <span class="kwd">INT</span> <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    quantity <span class="kwd">INT</span> <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    price <span class="type">DECIMAL</span>(<span class="num">10</span>, <span class="num">2</span>) <span class="kwd"><span class="kwd">NOT</span> NULL</span>,
    <span class="kwd">FOREIGN KEY</span> (order_id) <span class="kwd">REFERENCES</span> orders(id) <span class="kwd">ON</span> <span class="kwd">DELETE</span> <span class="kwd">CASCADE</span>,
    <span class="kwd">FOREIGN KEY</span> (product_id) <span class="kwd">REFERENCES</span> products(id)
);

<span class="com">-- 复杂查询示例：查询某个用户的所有订单及详情</span>
<span class="kwd">SELECT</span>
    o.id <span class="kwd">as</span> order_id,
    o.order_date,
    o.total_amount,
    o.<span class="kwd">status</span>,
    p.name <span class="kwd">as</span> product_name,
    oi.quantity,
    oi.price
<span class="kwd">FROM</span> orders o
<span class="kwd">INNER JOIN</span> order_items oi <span class="kwd">ON</span> o.id = oi.order_id
<span class="kwd">INNER JOIN</span> products p <span class="kwd">ON</span> oi.product_id = p.id
<span class="kwd">WHERE</span> o.customer_id = <span class="num">1</span>
<span class="kwd">ORDER BY</span> o.order_date DESC;</code></pre>
                                </div>
                    </details>
                </div>
            </div>
        </section>
    </main>
    </div>

</body>
</html>